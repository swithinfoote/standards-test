<table>
<colgroup>
<col style="width: 34%" />
<col style="width: 65%" />
</colgroup>
<tbody>
<tr class="odd">
<td><img src="media/image1.jpg" style="width:1.61806in;height:2.27917in"
alt="This image is a DIA graphic and for illustration only." /></td>
<td><p><strong>API Guidelines</strong></p>
<p><strong>Part B – API Security 2021</strong></p>
<p><strong>Version 2.0<br />
</strong><br />
<strong>Approved June 2021</strong></p></td>
</tr>
</tbody>
</table>
<p><strong><span class="smallcaps"><br />
</span></strong></p>
<p><img src="media/image2.png" style="width:0.81944in;height:0.27778in"
alt="THis is the Creative Commons logo" />Crown copyright ©. This
copyright work is licensed under the Creative Commons Attribution 4.0
International licence. In essence, you are free to copy, distribute and
adapt the work, as long as you attribute the work to the New Zealand
Government and abide by the other licence terms. <a
href="http://creativecommons.org/licenses/by/4.0/"><u>View a copy of
this licence</u></a> at
<u>http://creativecommons.org/licenses/by/4.0/</u></p>
<p>Please note that neither the New Zealand Government emblem nor the
New Zealand Government logo may be used in any way which infringes any
provision of the Flags, Emblems, and Names Protection Act 1981 or would
infringe such provision if the relevant use occurred within New Zealand.
Attribution to the New Zealand Government should be in written form and
not by reproduction of any emblem or the New Zealand Government logo.
Please see <a
href="http://www.legislation.govt.nz/act/public/1981/0047/latest/whole.html#dlm52216"><u>Flags,
Emblems, and Names Protection Act 1981</u></a> at
<u>http://www.legislation.govt.nz/act/public/1981/0047/latest/whole.html#dlm52216</u></p>
<p><img src="media/image3.png" style="width:3.23125in;height:0.8759in"
alt="T:\Logos\DIA Logo\DIA Logo - Black (Word Templates).png" /><img
src="media/image4.png" style="width:1.53472in;height:1.72083in" /></p>
<p>Published by the Department of Internal Affairs <a
href="http://www.digital.govt.nz"><u>www.digital.govt.nz</u></a></p>
<p><strong>Contents</strong></p>
<p><a href="#introduction"><strong>1 Introduction
<span>7</span></strong></a></p>
<p><a href="#scope"><strong>1.1 Scope <span>7</span></strong></a></p>
<p><a href="#target-audience"><strong>1.2 Target Audience
<span>8</span></strong></a></p>
<p><a href="#api-security"><strong>2 API Security
<span>9</span></strong></a></p>
<p><a href="#introduction-1"><strong>1.3 Introduction
<span>9</span></strong></a></p>
<p><a href="#domain-of-consideration"><strong>2.1.1 Domain of
Consideration <span>9</span></strong></a></p>
<p><a href="#domain-of-control"><strong>2.1.2 Domain of Control
<span>9</span></strong></a></p>
<p><a href="#identity-centric-and-holistic-view"><strong>2.1.3 Identity
Centric and Holistic View <span>10</span></strong></a></p>
<p><a href="#definitions"><strong>2.2 Definitions
<span>10</span></strong></a></p>
<p><a href="#risks"><strong>2.3 Risks <span>12</span></strong></a></p>
<p><a href="#mitigation-approach"><strong>2.3.1 Mitigation Approach
<span>13</span></strong></a></p>
<p><a href="#zero-trust-and-decoupled-environments"><strong>2.3.2 Zero
Trust and Decoupled Environments <span>14</span></strong></a></p>
<p><a href="#security-reference-architecture"><strong>2.4 Security
Reference Architecture <span>15</span></strong></a></p>
<p><a href="#actors-and-security-functional-capabilities"><strong>2.4.1
Actors and Security Functional Capabilities
<span>15</span></strong></a></p>
<p><a href="#building-secure-apis"><strong>2.5 Building Secure APIs
<span>19</span></strong></a></p>
<p><a href="#api-security-design-principles"><strong>2.5.1 API Security
Design Principles <span>20</span></strong></a></p>
<p><a href="#usage-patterns"><strong>3 Usage Patterns
<span>22</span></strong></a></p>
<p><a href="#pattern-1-internal-use-only"><strong>3.1 Pattern 1:
Internal Use only <span>22</span></strong></a></p>
<p><a href="#pattern-2-identifying-an-application-developer"><strong>3.2
Pattern 2: Identifying an Application Developer
<span>22</span></strong></a></p>
<p><a href="#pattern-3-anonymous-consuming-application"><strong>3.3
Pattern 3: Anonymous Consuming Application
<span>23</span></strong></a></p>
<p><a href="#pattern-4-identifying-a-consuming-application"><strong>3.4
Pattern 4: Identifying a Consuming Application
<span>23</span></strong></a></p>
<p><a
href="#pattern-5-authorising-a-system-to-system-interaction-b2b"><strong>3.5
Pattern 5: Authorising a System to System Interaction (B2B)
<span>24</span></strong></a></p>
<p><a href="#pattern-6-authorising-a-consuming-application"><strong>3.6
Pattern 6: Authorising a Consuming Application
<span>24</span></strong></a></p>
<p><a
href="#pattern-7-authorising-a-customer-delegated-authority"><strong>3.7
Pattern 7: Authorising a Customer (Delegated Authority)
<span>25</span></strong></a></p>
<p><a href="#pattern-8-decoupled-flow---ciba"><strong>3.8 Pattern 8:
Decoupled Flow - CIBA <span>26</span></strong></a></p>
<p><a href="#client-initiated-backchannel-authentication"><strong>3.9
(Client Initiated Backchannel Authentication)
<span>26</span></strong></a></p>
<p><a href="#quick-reference-table"><strong>3.10 Quick Reference Table
<span>27</span></strong></a></p>
<p><a href="#api-authentication-authorisation-basics"><strong>4 API
Authentication &amp; Authorisation Basics
<span>29</span></strong></a></p>
<p><a href="#authentication"><strong>4.1 Authentication
<span>29</span></strong></a></p>
<p><a href="#authentication-techniques"><strong>4.1.1 Authentication
Techniques <span>29</span></strong></a></p>
<p><a href="#oauth-2.0-basics"><strong>4.2 OAuth 2.0 Basics
<span>30</span></strong></a></p>
<p><a href="#resource-based-scopes-coarse-grained-access"><strong>4.2.1
Resource Based Scopes (Coarse Grained Access)
<span>32</span></strong></a></p>
<p><a href="#pkce-proof-key-for-code-exchange"><strong>4.2.2 PKCE (Proof
Key for Code Exchange) <span>32</span></strong></a></p>
<p><a href="#basic-oauth-2.0-implementation-patterns"><strong>4.3 Basic
OAuth 2.0 Implementation Patterns <span>33</span></strong></a></p>
<p><a href="#distributed-model---user-managed-access-uma"><strong>4.3.1
Distributed Model - User Managed Access (UMA)
<span>34</span></strong></a></p>
<p><a href="#openid-connect"><strong>4.4 OpenID Connect
<span>36</span></strong></a></p>
<p><a href="#basic-principles"><strong>4.4.1 Basic Principles
<span>36</span></strong></a></p>
<p><a href="#openid-connect-grant-flows"><strong>4.4.2 OpenID Connect
Grant Flows <span>37</span></strong></a></p>
<p><a href="#openid-connect-patterns"><strong>4.4.3 OpenID Connect
Patterns <span>38</span></strong></a></p>
<p><a href="#heart-working-group"><strong>4.4.4 Heart Working Group
<span>40</span></strong></a></p>
<p><a href="#ciba-flow"><strong>4.4.5 CIBA Flow
<span>40</span></strong></a></p>
<p><a href="#authorisation"><strong>4.5 Authorisation
<span>41</span></strong></a></p>
<p><a href="#authorisation-techniques"><strong>4.5.1 Authorisation
Techniques <span>41</span></strong></a></p>
<p><a href="#roles-based-access-controls-rbac"><strong>4.5.2 Roles Based
Access Controls (RBAC) <span>42</span></strong></a></p>
<p><a href="#scopes-limited-fine-grain-access"><strong>4.5.2.1 Scopes
(Limited Fine Grain Access) <span>42</span></strong></a></p>
<p><a href="#attribute-based-access-controls"><strong>4.5.3 Attribute
Based Access Controls <span>43</span></strong></a></p>
<p><a href="#api-gateway"><strong>4.5.4 API Gateway
<span>43</span></strong></a></p>
<p><a href="#security-controls"><strong>5 Security Controls
<span>44</span></strong></a></p>
<p><a href="#confidentiality-and-integrity"><strong>5.1 Confidentiality
and Integrity <span>44</span></strong></a></p>
<p><a href="#availability-and-threat-protection"><strong>5.2
Availability and Threat Protection <span>44</span></strong></a></p>
<p><a href="#logging-and-alerting"><strong>5.3 Logging and Alerting
<span>45</span></strong></a></p>
<p><a href="#api-security-use-case"><strong>6 API Security Use Case
<span>45</span></strong></a></p>
<p><a href="#high-level-view"><strong>6.1 High Level View
<span>46</span></strong></a></p>
<p><a href="#detailed-level-view"><strong>6.2 Detailed Level View
<span>47</span></strong></a></p>
<p><a href="#glossary-of-acronyms"><strong>8 Glossary of acronyms
<span>50</span></strong></a></p>
<p><a href="#further-reading"><strong>9 Further Reading
<span>52</span></strong></a></p>
<p><a
href="#appendix-a---standards-for-securing-restful-apis"><strong>10
Appendix A - Standards for Securing RESTful APIs
<span>53</span></strong></a></p>
<p><a href="#standards-for-securing-restful-apis"><strong>10.1 Standards
for Securing RESTful APIs <span>53</span></strong></a></p>
<p><a href="#appendix-b---authentication"><strong>11 Appendix B -
Authentication <span>57</span></strong></a></p>
<p><a href="#anonymous-authentication"><strong>11.1 Anonymous
Authentication <span>57</span></strong></a></p>
<p><a
href="#username-and-password-authentication-direct-authentication"><strong>11.2
Username and Password Authentication (Direct Authentication)
<span>57</span></strong></a></p>
<p><a href="#api-keys-authentication"><strong>11.3 API Keys
Authentication <span>60</span></strong></a></p>
<p><a href="#certificates-mutual-authentication"><strong>11.4
Certificates (Mutual) Authentication <span>61</span></strong></a></p>
<p><a href="#developer-authentication"><strong>11.5 Developer
Authentication <span>63</span></strong></a></p>
<p><a href="#multi-factor-authentication-mfa"><strong>11.6 Multi Factor
Authentication (MFA) <span>64</span></strong></a></p>
<p><a href="#appendix-c---oauth-2.0"><strong>12 Appendix C - OAuth 2.0
<span>65</span></strong></a></p>
<p><a href="#grant-types"><strong>12.1 Grant Types
<span>65</span></strong></a></p>
<p><a
href="#appendix-d---oauth-2.0-and-openid-connect-tokens-credentials"><strong>13
Appendix D - OAuth 2.0 and OpenID Connect Tokens &amp; Credentials
<span>68</span></strong></a></p>
<p><a href="#oauth-scenario-authorisation-code-grant-flow"><strong>13.1
OAuth Scenario (Authorisation Code Grant Flow)
<span>70</span></strong></a></p>
<p><a href="#stage-1-develop-the-application-3rd-party"><strong>13.1.1
Stage 1 – Develop the Application (3<sup>rd</sup> Party)
<span>71</span></strong></a></p>
<p><a href="#stage-2-register-the-client-application"><strong>13.1.2
Stage 2 – Register the (Client) Application
<span>71</span></strong></a></p>
<p><a
href="#stage-3-customer-sets-new-service-and-authorises-access"><strong>13.1.3
Stage 3 –Customer Sets New Service and Authorises Access
<span>72</span></strong></a></p>
<p><a
href="#stage-4-authentication-and-approval-by-the-resource-owner"><strong>13.1.4
Stage 4 – Authentication and Approval by the Resource Owner
<span>73</span></strong></a></p>
<p><a href="#stage-5-provide-an-authentication-code"><strong>13.1.5
Stage 5 – Provide an Authentication Code
<span>74</span></strong></a></p>
<p><a
href="#stage-6-authorisation-code-is-sent-to-token-endpoint"><strong>13.1.6
Stage 6 –Authorisation Code is Sent to Token Endpoint
<span>74</span></strong></a></p>
<p><a href="#stage-7-the-access-token-it-provides"><strong>13.1.7 Stage
7 – The Access Token It Provides <span>75</span></strong></a></p>
<p><a
href="#stage-8-the-client-application-uses-the-access-token-to-access-the-resource"><strong>13.1.8
Stage 8 – The Client Application uses the Access Token to Access the
Resource <span>76</span></strong></a></p>
<p><a href="#_Toc74234793"><strong>14 Appendix E - Authorisation
<span>77</span></strong></a></p>
<p><a href="#abac-implementation"><strong>14.1 ABAC Implementation
<span>77</span></strong></a></p>
<p><a href="#appendix-f---security-controls"><strong>15 Appendix F -
Security Controls <span>79</span></strong></a></p>
<p><a href="#communications-security-confidentiality"><strong>15.1
Communications Security (Confidentiality)
<span>79</span></strong></a></p>
<p><a href="#state-integrity"><strong>15.2 State (Integrity)
<span>79</span></strong></a></p>
<p><a href="#content-encryption-confidentiality"><strong>15.3 Content
Encryption (Confidentiality) <span>79</span></strong></a></p>
<p><a href="#content-signing-integrity"><strong>15.4 Content Signing
(Integrity) <span>80</span></strong></a></p>
<p><a href="#non-repudiation-integrity"><strong>15.5 Non-Repudiation
(Integrity) <span>80</span></strong></a></p>
<p><a href="#availability-and-threat-protection-1"><strong>15.6
Availability and Threat Protection <span>80</span></strong></a></p>
<p><a href="#token-threat-mitigation"><strong>15.7 Token Threat
Mitigation <span>81</span></strong></a></p>
<p><a href="#_Toc74234803"><strong>16 Appendix G - IETF NFC Relating to
OAuth 2.0 <span>83</span></strong></a></p>
<p><a href="#appendix-h---rfcs-in-development"><strong>17 Appendix H -
RFCs in Development <span>87</span></strong></a></p>
<p><strong>Figures</strong></p>
<p><a href="#_Toc74234863"><strong>Figure 11: API Security
Considerations <span>9</span></strong></a></p>
<p><a href="#_Toc74234864"><strong>Figure 12: Identity Centric
<span>10</span></strong></a></p>
<p><a href="#_Toc74234865"><strong>Figure 13: API Actors &amp; Core
Components <span>15</span></strong></a></p>
<p><a href="#_Toc74234866"><strong>Figure 14: Split API Support Stack
<span>19</span></strong></a></p>
<p><a href="#_Toc74234867"><strong>Figure 15: Internal API Security
<span>22</span></strong></a></p>
<p><a href="#_Toc74234868"><strong>Figure 16: Developer Authentication
to API Access <span>23</span></strong></a></p>
<p><a href="#_Toc74234869"><strong>Figure 17: Unidentified Consuming
Application <span>23</span></strong></a></p>
<p><a href="#_Toc74234870"><strong>Figure 18: Consuming Application
Identification <span>24</span></strong></a></p>
<p><a href="#_Toc74234871"><strong>Figure 19: System to System
Authorisation <span>24</span></strong></a></p>
<p><a href="#_Toc74234872"><strong>Figure 20: Consuming Application
Authorisation <span>25</span></strong></a></p>
<p><a href="#_Toc74234873"><strong>Figure 21: Delegated Authority
<span>25</span></strong></a></p>
<p><a href="#_Toc74234874"><strong>Figure 22: Decoupled Flow
<span>26</span></strong></a></p>
<p><a href="#_Toc74234875"><strong>Figure 23: Authentication Options
<span>30</span></strong></a></p>
<p><a href="#_Toc74234876"><strong>Figure 24: OAuth 2.0 Components
<span>31</span></strong></a></p>
<p><a href="#_Toc74234877"><strong>Figure 25: OAuth 2.0 Implementation
Models <span>33</span></strong></a></p>
<p><a href="#_Toc74234878"><strong>Figure 26: OAuth 2.0 Models
(co-location of Authorisation &amp; Authentication Services)
<span>34</span></strong></a></p>
<p><a href="#_Toc74234879"><strong>Figure 27: User Managed Access
<span>35</span></strong></a></p>
<p><a href="#_Toc74234880"><strong>Figure 28: OpenID Connect -
Distributed Authorisation &amp; Authentication Server
<span>39</span></strong></a></p>
<p><a href="#_Toc74234881"><strong>Figure 29: OpenID Connect &amp; OAuth
<span>39</span></strong></a></p>
<p><a href="#_Toc74234882"><strong>Figure 30: Authorisation Techniques
<span>42</span></strong></a></p>
<p><a href="#_Toc74234883"><strong>Figure 31: API Gateway for
Authorisation <span>44</span></strong></a></p>
<p><a href="#_Toc74234884"><strong>Figure 32: API Security Use Case High
Level View <span>46</span></strong></a></p>
<p><a href="#_Toc74234885"><strong>Figure 33: API Security Use Case
Detailed Level View <span>47</span></strong></a></p>
<p><a href="#_Toc74234886"><strong>Figure 34: Anonymous Authentication
Model <span>59</span></strong></a></p>
<p><a href="#_Toc74234887"><strong>Figure 35: HTTP Basic / Digest
Authentication Model <span>60</span></strong></a></p>
<p><a href="#_Toc74234888"><strong>Figure 36: API Key Authentication
<span>62</span></strong></a></p>
<p><a href="#_Toc74234889"><strong>Figure 37: Certificate Authentication
<span>64</span></strong></a></p>
<p><a href="#_Toc74234890"><strong>Figure 38: API Portal Login Page
<span>65</span></strong></a></p>
<p><a href="#_Toc74234891"><strong>Figure 39: Stage 2 Client
Registration <span>74</span></strong></a></p>
<p><a href="#_Toc74234892"><strong>Figure 40: Stage 3 Client
Registration <span>75</span></strong></a></p>
<p><a href="#_Toc74234893"><strong>Figure 41: Stage 4 Client
Registration <span>75</span></strong></a></p>
<p><a href="#_Toc74234894"><strong>Figure 42: Stage 5 Client
Registration <span>76</span></strong></a></p>
<p><a href="#_Toc74234895"><strong>Figure 43: Stage 6 Client
Registration <span>77</span></strong></a></p>
<p><a href="#_Toc74234896"><strong>Figure 44: Stage 7 Client
Registration <span>77</span></strong></a></p>
<p><a href="#_Toc74234897"><strong>Figure 45: Stage 8 Client
Registration <span>78</span></strong></a></p>
<p><a href="#_Toc74234898"><strong>Figure 46: XACML Reference
Architecture <span>79</span></strong></a></p>
<p><a href="#_Toc74234899"><strong>Figure 47: ABAC Support for APIs
<span>80</span></strong></a></p>
<p><strong>Tables</strong></p>
<p><a href="#_Toc74234992"><strong>Table 8: Actors &amp; Devices
<span>16</span></strong></a></p>
<p><a href="#_Toc74234993"><strong>Table 9: Core Components
<span>18</span></strong></a></p>
<p><a href="#_Toc74234994"><strong>Table 10: Quick Reference Table
<span>27</span></strong></a></p>
<p><a href="#_Toc74234995"><strong>Table 6: Glossary of Terms
<span>50</span></strong></a></p>
<p><a href="#_Toc74234996"><strong>Table 7: Glossary of acronyms
<span>52</span></strong></a></p>
<p><a href="#_Toc74234997"><strong>Table 11: Further reading
<span>54</span></strong></a></p>
<p><a href="#_Toc74234998"><strong>Table 12: API Security Standards
<span>57</span></strong></a></p>
<p><a href="#_Toc74234999"><strong>Table 13: OAuth 2.0 Grant Types
<span>68</span></strong></a></p>
<p><a href="#_Toc74235000"><strong>Table 14: OAuth 2.0 Tokens &amp;
Credentials <span>73</span></strong></a></p>
<p><a href="#_Toc74235001"><strong>Table 15: Risks &amp; Mitigations
<span>83</span></strong></a></p>
<p><a href="#_Toc74235002"><strong>Table 16: Token Threat Mitigation
<span>84</span></strong></a></p>
<p><a href="#_Toc74235003"><strong>Table 17: IETF NFC Relating to OAuth
2.0 <span>88</span></strong></a></p>
<p><a href="#_Toc74235004"><strong>Table 18: RFCs in Development
<span>91</span></strong></a></p>
<h1 id="introduction">Introduction</h1>
<p>The Strategy for a Digital Public Service is “a call to action for
the public service to operate in the digital world, in a more modern and
efficient way — delivering the outcomes that Aotearoa New Zealand
needs.”</p>
<p>It envisions a future where agencies prioritise the creation of open
Application Programming Interfaces (APIs) to enable reuse of data,
transactions and rules, which, in turn, creates an opportunity for
greater cooperation and interoperability between agencies, to
dramatically improve service design and delivery.</p>
<p>Agencies need focused guidance, approaches and techniques to help
increase their knowledge and skills around APIs. There is a wide range
in the level of knowledge and skill regarding API design and delivery
across Government agencies.</p>
<p>Hence, this document tries to offer a balance of guidance for those
new to APIs along with quick lookup standards, which should assist
agencies in achieving consistency and commonality in their API
deliverables.</p>
<h2 id="scope">Scope</h2>
<p>This document aims to provide a set of high-level standards with
design and implementation guidance, along with low-level API best
practices to guide government agencies in their development of APIs.</p>
<ul>
<li><p><strong>Part A – API Concepts and Management 2021<br />
</strong>Looks at the business context for APIs within government and
articulates the principles and considerations that could impact an
agency when creating APIs. It looks at APIs in the context of their
impact on the organisation as well as across government and public
services through to commercial innovation. Version 1.0 published in 2016
was called API Standard and Guidelines - Part A – Business.</p></li>
<li><p><strong>Part B – API Security 2021<br />
</strong>Part B (this document) contains the API Security reference
architecture and technical details for implementing API Security.
Version 1.0 published in 2016 was called API Standard and Guidelines -
Part A – Technical but has been split into a Part B - Security and Part
C – Development for this version 2.0.</p></li>
<li><p><strong>Part C – Development<br />
</strong>Part C contains the technical details for API Development,
including general API implementation standards for API developers &amp;
consuming application developers. Version 1.0 published in 2016 was
called API Standard and Guidelines - Part A – Technical but has been
split into a Part B - Security and Part C – Development for this version
2.0.</p></li>
</ul>
<blockquote>
<p>The guidance in this document set is intended to apply to all API
standards and protocols, however much of the guidance is oriented to
REST APIs.</p>
<p>Applicable technical standards are referenced throughout the document
set and are intended to provide detailed guidance for developers of API
standards.</p>
<p>Examples presented in this document are purely illustrative examples,
and do not represent recommended API design and/or data content
requirements for the New Zealand Government.</p>
<p>The document will use hypothetical or actual use cases with a
government context to illustrate practical application of the concepts
described.</p>
</blockquote>
<h2 id="target-audience">Target Audience</h2>
<p>The target audience for this document is primarily solution designers
and API developers within, or contracted to, agencies and organisations
within the public service of New Zealand.</p>
<p>Additionally, compliance and assurance personnel may be interested,
as well, in terms of assessing alignment with the standards and
guidelines.</p>
<h1 id="api-security">API Security</h1>
<h2 id="introduction-1">Introduction</h2>
<p>According to Gartner, by 2022, API abuses will be the most-frequent
attack vector for enterprise web application data breaches. As such,
securing RESTful APIs is fundamental to the success of any API Strategy
or implementation; any approach should include the following three key
areas:</p>
<ol type="a">
<li><p>Domain of Consideration</p></li>
<li><p>Domain of Control</p></li>
<li><p>Identity<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a>-centric and Holistic View</p></li>
</ol>
<h3 id="domain-of-consideration">Domain of Consideration</h3>
<p>Developing and securing RESTful APIs is more than just applying
standards; it is a framework and state of mind that has to be understood
and followed jointly by the business owners, IT architects and
developers. The API Security framework must be defined at the
organisation and business level and should always consider who, how and
what users and applications (both internal and external to an
organisation) will interact with the APIs. These considerations should
be defined at the beginning of any project and driven from a desired
business outcome e.g. provide real time information for the public about
the closest location and address of a GP.</p>
<p><img src="media/image5.png" style="width:5.90139in;height:2.89306in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234863" class="anchor"></span>Figure 11: API Security
Considerations</p>
<h3 id="domain-of-control">Domain of Control</h3>
<p>The Domain of Control contains the components (defined further in
this document) that need to be developed, deployed and they need to work
together to provide API security to support:</p>
<ul>
<li><p>Registered application developer access to the API</p></li>
<li><p>Authenticated and authorised consuming application access to the
API or Events</p></li>
<li><p>Protected communication between the API, the Event Broker and the
consuming application to ensure confidentiality and integrity</p></li>
<li><p>The ability for applications to act on behalf of a
customer</p></li>
</ul>
<h3 id="identity-centric-and-holistic-view">Identity Centric and
Holistic View</h3>
<p>The security of APIs should not just be seen as a bounded solution
i.e. only the components illustrated in security considerations above
but needs to be seen from a holistic perspective. It needs to
incorporate existing enterprise security frameworks where the management
and understanding of user identities is core. For example, securing an
API that is targeted for a mobile application is not just about applying
an OAuth profile, it should take into consideration how mobile devices
and applications are managed and secured and how the enterprise security
framework (e.g. authentication) can be leveraged.</p>
<p><img src="media/image6.png"
style="width:2.82067in;height:2.44627in" /></p>
<p><span id="_Toc74234864" class="anchor"></span>Figure 12: Identity
Centric</p>
<p>People- (or User-) centric security frameworks are key to defining
the required access policies and controls for APIs. The management of
Identity (this includes users, device, servers and applications) should
be central to any API security framework.</p>
<h2 id="definitions">Definitions</h2>
<p>This version of the API Guidelines expends its remit, its main focus
is still on REST but GraphQL, AsyncAPI and gRPC specifications are
included under the banner of APIs.</p>
<p>These additional types of API are covered in Section C (API
Development) but from a high-level perspective the definitions below
apply to all four API types.</p>
<p>For this standard the following definitions are used:</p>
<ul>
<li><p><strong>Authentication</strong> is the process of verifying the
identity of a customer (or device) who presents identity credentials and
authentication key(s);</p></li>
<li><p><strong>Authentication Authority –</strong> is a system entity
that provides authentication services to ensure only permitted customers
(or devices) gain access</p></li>
<li><p><strong>Authorisation</strong> is the process of verifying that a
customer (or device) has the right to perform an action and what they
are allowed to access;</p></li>
<li><p><strong>Availability</strong> is the ability to minimise API
downtime by implementing threat protection;</p></li>
<li><p><strong>Confidentiality</strong> is the ability to ensure
information that is sent between Users, Applications and Servers is only
visible to those authorised to use it;</p></li>
<li><p><strong>Delegation</strong> is when a user authorises another
user (or device) to serve as his or her representative for a particular
task;</p></li>
<li><p><strong>Delegated Authorisation</strong> is a framework that
defines how an owner of a set of resources can grant access (delegate)
to a designated user or consuming application to perform actions on some
of those resources on the owner’s behalf, but without sharing their
credentials;</p></li>
<li><p><strong>Federation</strong> is the process that allows for the
leverage and reuse of identity credentials to multiple Authentication
Authorities for authentication and/or Single Sign On;</p></li>
<li><p><strong>Integrity</strong> is the ability to ensure that
information received has not been modified by a third party, also
providing non-repudiation services;</p></li>
<li><p><strong>Provisioning</strong> is the automated or manual service
for aggregating and correlating identity data resulting in the creation
of user (IT) accounts and the delivery of user meta data used by systems
to define access policies and controls for services.</p></li>
<li><p><strong>Threat protection</strong> is the service for protecting
APIs (at the ingress and egress points of an organisation) from known
threats (e.g. the OWASP top 10) by preventing misuse or loss of
availability. Note: Threat protection should also be addressed at the OS
hardening level and should be an integral part of the API software
development;</p></li>
<li><p><strong>User Managed Access</strong> has been developed to
provide a user data delegation model which enables a resource owner to
control the authorisation of data sharing and other protected-resource
access made between online services on the owner’s behalf or with the
owner’s authorisation by an autonomous requesting party;</p></li>
<li><p><strong>Consent Management</strong> is the process that manages
the collection of user data, ensuring that the required policies are
applied, and the required consent has been obtained from the user,
allowing the user to understand how the data is used and to be able to
opt out if required. This is being driven by many global Privacy
Laws.</p></li>
<li><p><strong>Zero Trust (ZT)</strong> is the term for an evolving set
of cybersecurity paradigms that move network defences from static,
network-based perimeters to focus on users, assets, and resources. A
zero-trust architecture (ZTA) uses zero-trust principles to plan
enterprise infrastructure and workflows. Zero trust assumes there is no
implicit trust granted to assets or user accounts based solely on their
physical or network location</p></li>
</ul>
<blockquote>
<p><em><strong>Note</strong></em>: A customer/user can be internal or
external to a Government Agency.</p>
</blockquote>
<h2 id="risks">Risks </h2>
<p><mark>APIs are another channel into an organisation’s resources and
information. Most organisations are accustomed to exposing a web
interface, with good control over what information is released via that
interface. APIs offer direct, machine to machine access to resources and
information, which makes it less obvious when information is incorrectly
exposed. It becomes increasingly important for internal business
stakeholders to decide what information and resources should be released
via this channel, and to whom.</mark></p>
<p><mark>The security risks that APIs introduce will be similar to the
traditional risks experienced on any web channel (web sites and web
applications), except there is:</mark></p>
<ul>
<li><p>Increased attack surface due to more ways in, multiple services
to potentially exploit </p></li>
<li><p>Risk of inadvertently exposing back-end data, back-end
architecture and back-end applications</p></li>
<li><p>Potential for greater consequences if your API is
compromised/hijacked and serves up malicious payloads to
consumers</p></li>
<li><p>Greater privacy concerns where APIs involve personally
identifiable information</p></li>
<li><p>Risks of malware in uploaded files due to performance overhead or
lack on inline scanning</p></li>
<li><p>Risk of malformed APIs that are developed with limited security
validation and inappropriate security validation</p></li>
<li><p>Risk related to cloud and container-based systems where security
best practices are not applied.</p></li>
</ul>
<p>Risks posed by APIs include loss of integrity, confidentiality and
availability of data, for example:</p>
<ul>
<li><p>Loopholes retrieving API resources may offer access to more
information than was intended (especially if fields requested are built
straight into a DB query)</p></li>
<li><p>Write operations offer a means of polluting data stores, feeding
misinformation into a system</p></li>
<li><p>Write operations could be used to form a Denial of Service attack
by overloading the server or data store</p></li>
<li><p>Use of wildcards in search fields can shut down APIs and back-end
applications</p></li>
<li><p>Cross site scripting attacks made possible by consuming
applications not checking user inputs</p></li>
<li><p>SQL injection into consuming applications which cause database
damage at the API backend</p></li>
<li><p>Parameter attacks such as HTTP Parameter Pollution (HPP)</p></li>
<li><p>Man-in-the-middle attacks, modifying API requests or responses
leading to data eavesdropping or misinformation insertion</p></li>
<li><p>Subverting authentication or authorisation mechanisms to spoof
messages from legitimate consumers</p></li>
<li><p>Credential leakage or stealing authentication tokens to obtain
information illicitly</p></li>
<li><p>System information leakage through API error messages revealing
details about an API’s construction or underlying system makeup</p></li>
<li><p>Broken Session IDs, Keys and authentication create exposure to
unauthorized access through authentication factors that are not
functioning because of poor security design or technology bugs.</p></li>
<li><p>Other broken resource identifiers, authentication and
authorisation mechanisms, allowing attackers to exploit flaws to obtain
access, either temporarily or permanently.</p></li>
<li><p>Exposing too much information through the use of generic resource
APIs rather than specialising APIs for each specific
circumstance</p></li>
</ul>
<h3 id="mitigation-approach">Mitigation Approach</h3>
<p>API risks need to be mitigated in a number of ways. There is no
single off-the-shelf security solution which can be dropped in to
address all aspects of API security. APIs need to be secure by design;
security needs to be built in from scratch and be considered within the
context of existing protection mechanisms.</p>
<p>The main areas that API Security covers are:</p>
<ol type="a">
<li><p>Identity and Access Management (IdAM) to provide the following
services:</p>
<ul>
<li><p>Authentication</p></li>
<li><p>Authorisation and delegated authority</p></li>
<li><p>Federation</p></li>
</ul></li>
<li><p>Confidentiality</p></li>
<li><p>Integrity</p></li>
<li><p>Availability and Threat Protection</p></li>
<li><p>Logging, Alerting and Incident Management</p></li>
</ol>
<p>This ensures that:</p>
<ul>
<li><p>The consuming application is known and can only get access to API
resources they are allowed to</p></li>
<li><p>Message content has not been tampered with between consumer and
provider</p></li>
<li><p>Resources are reliably from the provider intended when the
consuming application made the request</p></li>
<li><p>The API will be available when needed, and not brought down by
attacks from malicious consuming applications</p></li>
</ul>
<p>In order to address API security risks, a security framework is
needed which encapsulates all the aspects of security listed above.</p>
<h3 id="zero-trust-and-decoupled-environments">Zero Trust and Decoupled
Environments</h3>
<p>A Zero Trust Network Access model has been talked about for a number
of years. In the current environment it is now seen by many analysts as
the direction organisations need to take. This section highlights areas
of the model that can help mitigate risks related to APIs.</p>
<p>Zero Trust Architecture<a href="#fn2" class="footnote-ref"
id="fnref2" role="doc-noteref"><sup>2</sup></a> removed the concept of
trusted internal and untrusted external networks and focuses on the
policy of “never trust always verify”.</p>
<p>The selection of cloud services has changed this security model to
one where all actors (employees, partners etc) require access controls
no matter where they are coming from or on.</p>
<p>Zero Trust is seen as an architecture that is critical for
organisations moving towards decoupled microservices and API
architectures.</p>
<p>Microservices architectures are the backbone of many API services
offered by organisations and have embraced the concepts of identity and
how permissions are created and enforced between different services.</p>
<p>Every microservice requires an identity which can be confirmed, and
the required permissions and policies applied which should be based on
attributes and contextual access.</p>
<p>The following are some of the areas that need to be considered by an
organisation when planning their implementation of Zero Trust:</p>
<ul>
<li><p>Apply Strong Identification and Authentication</p></li>
<li><p>Build a digital trust model that is dynamic, and trust is only
valid for the current session</p></li>
<li><p>Constant evaluation</p></li>
<li><p>Always authenticate</p></li>
<li><p>Apply contextual authorisation (Attributes, Consent, Location,
Time, behaviour etc)</p></li>
<li><p>Build in a Digital Risk capability that maps to a level of
confidence and constantly re-evaluates</p></li>
<li><p>Leverage IAM capability from Identity proofing to Adaptive
Authentication</p></li>
<li><p>Incorporate Endpoint security</p></li>
<li><p>Transaction Level verification and Continuous session
validation</p></li>
<li><p>Ensure Data Security is applied with reference to Encryption and
User privacy controls including consent management</p></li>
<li><p>Implement strong Auditing, Logging, Event reporting and Forensics
providing insight and behavioural patterns</p></li>
<li><p>Smart Threat detection with Machine Learning</p></li>
<li><p>Inject Identity context into the API traffic (User, Application,
Device etc)</p></li>
<li><p>Use JWT to provide secure and validated claims, which can also be
encrypted</p></li>
<li><p>Apply Fine grained access at the egress point, allowing the
Enforcement point to allow, block filter or modify the response</p></li>
<li><p>Identity Propagation to backend services to make
decisions</p></li>
<li><p>JWTs limit chatter in microservice environments</p></li>
<li><p>All APIs should be secured and treated as if they are public
APIs.</p></li>
</ul>
<h2 id="security-reference-architecture">Security Reference
Architecture</h2>
<blockquote>
<p>This section describes an API Security Reference Architecture and its
component parts to inform the construction of an API security
framework.</p>
<p>It is important to note that REST, gRPC, GraphQL and AsyncAPI are
different architectural models for building synchronous and asynchronous
APIs that can leverage the Security Controls (e.g. OAuth 2.0 and OpenID
Connect) defined in this document; but they all have their own intrinsic
security models (e.g. throttling consideration in GraphQL) that are not
covered in this document.</p>
</blockquote>
<h3 id="actors-and-security-functional-capabilities">Actors and Security
Functional Capabilities</h3>
<blockquote>
<p>Identity and Access Management defines the actors (users and devices)
who interact with system components that manage and expose APIs. Figure
13 shows a typical model of API components (support stack) and actors.
The actors and components are described in Table and Table 8.</p>
</blockquote>
<p><img src="media/image7.png" style="width:5.90139in;height:3.22014in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234865" class="anchor"></span>Figure 13: API Actors
&amp; Core Components</p>
<blockquote>
<p>The green areas highlight internal actors while the yellow areas
highlight the external actors.</p>
<p>The components defined remain valid no matter what API architecture
(internal, cloud, hybrid) is implemented.</p>
</blockquote>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 82%" />
</colgroup>
<thead>
<tr class="header">
<th colspan="2">Actors and Devices</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>External Users</td>
<td><ul>
<li><p>Customers - the public, other agencies and partners who use
consuming applications to access resources via APIs.</p></li>
<li><p>External application developers who build software to access
resources via APIs</p></li>
</ul></td>
</tr>
<tr class="even">
<td>Devices</td>
<td><ul>
<li><p>PC Browsers running web applications</p></li>
<li><p>Mobile Devices running apps</p></li>
<li><p>Servers running systems with server-to server
communications</p></li>
</ul></td>
</tr>
<tr class="odd">
<td>Internal Users</td>
<td><ul>
<li><p>Internal API Developers who build APIs</p></li>
<li><p>Internal Application Developers who build software which accesses
resources via APIs</p></li>
<li><p>Business Owners responsible for the API product(s)</p></li>
<li><p>Security responsible for ensuring the APIs are secure</p></li>
</ul></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234992" class="anchor"></span>Table 8: Actors &amp;
Devices</p>
<blockquote>
<p>The core components of an API Security Framework (the development
portal, manager and gateway) provide a grouping of functionality. These
functions can be delivered with discrete applications, or bespoke code
development, via COTS products or through leveraging existing devices
that can be configured to provide these functions / services. Note: some
of the functionality may overlap or be combined into one or more
products depending on the vendor used.</p>
<p>The following lists the functions of a mature API delivery and
security framework for an agency that is working with the development
community. Together, these functions provide full support for the
application developer building and developing consuming applications
that will use the API(s) exposed by the agency.</p>
<p>Depending on the requirements of the agency, some of these functions
might not be required e.g. if the agency API exposed is purely for
public consumption and only allows consuming applications to read
information, then only a solution for enforcing threat protection (i.e.
Denial of Service) might be required, and this could be delivered using
an existing service protection capability.</p>
</blockquote>
<table>
<colgroup>
<col style="width: 16%" />
<col style="width: 83%" />
</colgroup>
<thead>
<tr class="header">
<th colspan="2">Core Components</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>API Portal</td>
<td><p>The API Portal often provides the following functions for
internal and external application developers:</p>
<ul>
<li><p>Discovery of APIs</p></li>
<li><p>Analytics to monitor APIs</p></li>
<li><p>Access to specifications and descriptions of APIs, including
SLAs</p></li>
<li><p>Social network capability to share and publish ideas</p></li>
</ul>
<p>Also supports the development, build and test of consuming
applications.</p></td>
</tr>
<tr class="even">
<td>API Manager</td>
<td><p>The API Manager functions cover:</p>
<ul>
<li><p>Centralised API administration and governance for API
catalogues</p></li>
<li><p>Management of registration and on-boarding processes for
communities of API developers</p></li>
<li><p>Lifecycle Management of APIs</p></li>
<li><p>Applying pre-defined security profiles</p></li>
<li><p>Security policy administration / definition</p></li>
<li><p>Policy evaluation</p></li>
</ul></td>
</tr>
<tr class="odd">
<td>API Gateway</td>
<td><p>The API Gateway capability can provide the following:</p>
<ul>
<li><p>Act as the API proxy or the host acting as the primary point of
access for exposed APIs</p></li>
<li><p>Enforce threat protection, throttling and quota
management</p></li>
<li><p>Authorisation Services to control access to APIs</p></li>
<li><p>Authentication Services to ensure only permitted users
(internal/external) have access to the API</p></li>
<li><p>Security Policy enforcement</p></li>
<li><p>Monitoring and analytics for business and security
analysts</p></li>
</ul></td>
</tr>
<tr class="even">
<td>Event Broker</td>
<td><p>The Event Broker (or "broker") is responsible for receiving
events (aka messages) from publishers (services) and delivering them to
subscribers (services), that is, the consumers who have registered
interest in events of that type.</p>
<p>Brokers often store events until they are delivered, which is what
makes event driven architectures very resilient to failures. Examples of
brokers are RabbitMQ, Apache Kafka and Solace.</p>
<p>With the emergence of an AsyncAPI standard, event driven
architectures are becoming more prevalent.</p></td>
</tr>
<tr class="odd">
<td>API Documentation</td>
<td><p>OpenAPI (REST APIs) and AsyncAPI are API (message and event-based
APIs) documentation specifications in a machine-readable format</p>
<p><a
href="https://github.com/asyncapi/bindings"><u>https://github.com/asyncapi/bindings</u></a></p></td>
</tr>
<tr class="even">
<td>API Monitoring and Analytics</td>
<td><p>Business owners and security specialists need to be able to
monitor the use of APIs:</p>
<ul>
<li><p>Monitor uptake of API services</p></li>
<li><p>Define when to deprecate an old version</p></li>
<li><p>Profile usage for business</p></li>
<li><p>Profile usage for security baselines</p></li>
<li><p>Detect and respond to security events (SEIM)</p></li>
</ul>
<p>This helps adapt to change in usage/demand.</p></td>
</tr>
<tr class="odd">
<td>Credential Stores</td>
<td><p>The credential stores are identity and key stores which are used
to securely store:</p>
<ul>
<li><p>Internal and external user objects, and possibly groups</p></li>
<li><p>API keys and secrets, certificates etc.</p></li>
</ul>
<p>These stores are used by the API Gateway for authorisation and
authentication services</p></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234993" class="anchor"></span>Table 9: Core
Components</p>
<blockquote>
<p>The model can also be split, with the API support stack duplicated –
one set to support internal API usage and one set to support external
use:</p>
</blockquote>
<p><img src="media/image8.png" style="width:5.90139in;height:3.67014in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234866" class="anchor"></span>Figure 14: Split API
Support Stack</p>
<blockquote>
<p>Authentication, authorisation, confidentiality, integrity and
availability can be applied across the components in the support stack,
depending on component capabilities.</p>
<p>The actual configuration and location of the API functional
capabilities will vary depending on individual circumstances (e.g. some
capabilities may be internal, some may be in the cloud, where API
development is outsourced then ‘internal’ functional stack may belong to
the outsourcer etc.). Also, some components might not be required or can
be developed in house.</p>
</blockquote>
<h2 id="building-secure-apis">Building Secure APIs</h2>
<blockquote>
<p>Building in security starts from the ground up, so development of
APIs needs to be done with awareness of the API security risks
associated with the resources and information being exposed, and with
appropriate mitigations in place for these API security risks.</p>
<p>When developing an API is it advisable to carefully consider
potential malicious use, especially:</p>
</blockquote>
<ul>
<li><p>PUTs and POSTs – which change internal data and could be used to
attack or misinform</p></li>
<li><p>DELETEs – which could be used to remove the contents of an
internal resource repository</p></li>
</ul>
<blockquote>
<p>Standard secure coding practices are always recommended (see <a
href="https://wiki.owasp.org/index.php/Security_by_Design_Principles"><u>OWASP
Security by Design Principles</u></a>), in line with New Zealand
Information Security Manual (NZISM) guidance. But API development should
take special note of the following:</p>
</blockquote>
<ul>
<li><p>Design Driven Development (refer to Part C)</p></li>
<li><p><a href="https://owasp.org/www-project-top-ten/"><u>OWASP Top
Ten</u></a> – A summary of the standard attacks and mitigations</p></li>
<li><p><a
href="https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html"><u>REST
Security Cheat Sheet</u></a> – REST-specific risks and how to prevent
them, e.g. input validation</p></li>
<li><p><a href="https://owasp.org/www-project-api-security/"><u>OWASP
API Security Project</u></a> – Top 10 API-specific risks and how to
prevent them</p></li>
</ul>
<blockquote>
<p>The <a href="https://cheatsheetseries.owasp.org/index.html"><u>OWASP
Cheat Sheet Series</u></a> provides cheat sheets on a variety of
security-related subjects. It is worth reviewing them to see if others
may apply to your specific circumstances. Special note should be taken
of the following where your API accepts input values as parameters:</p>
</blockquote>
<ul>
<li><p><a
href="https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html"><u>OWASP
Input Validation Cheat Sheet</u></a> – A summary of input risks and
mitigations</p></li>
<li><p><a
href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html"><u>OWASP
Cross Site Scripting Prevention Cheat Sheet</u></a> – how to escape
inputs to prevent cross site scripting</p></li>
<li><p><a
href="https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html"><u>OWASP
SQL Injection Prevention Cheat Sheet</u></a> – ensuring database queries
are built internally</p></li>
<li><p><a
href="https://cheatsheetseries.owasp.org/cheatsheets/Query_Parameterization_Cheat_Sheet.html"><u>OWASP
Query Parameterization Cheat Sheet</u></a> – examples of SQL injection
and stored procedure vulnerabilities</p></li>
</ul>
<blockquote>
<p>It is also recommended that a security testing capability be
incorporated into the development cycle which provides continuous,
repeatable and automated tests to find security vulnerabilities in APIs
and web applications during development and testing.</p>
</blockquote>
<h3 id="api-security-design-principles">API Security Design Principles
</h3>
<blockquote>
<p>The following are key principles that should be applied when
designing API security frameworks:</p>
</blockquote>
<ol type="1">
<li><p>Design with the objective that the API will eventually be
accessible from the public internet, even if there are no plans to do so
at the moment</p></li>
<li><p>Security first – build security into the API when they are being
developed</p></li>
<li><p>Use a common authentication and authorisation pattern, preferably
based on existing security components: avoid creating a bespoke solution
for each API</p></li>
<li><p>Least Privilege - Access and authorisation should be assigned to
API consumers based on the minimal amount of access they need to carry
out the functions required, and strong authentication and authorization
models are applied</p></li>
<li><p>Maximise entropy (randomness) of security credentials by using
API Keys rather than username and passwords for API authorisation, as
API Keys provide an attack surface that is more challenging for
potential attackers</p></li>
<li><p>Balance performance with security with reference to key life
times and encryption / decryption overheads</p></li>
<li><p>Manage the exposure and lifetime of all APIs, and ensure all
organisation APIs are covered by proactive scanning</p></li>
<li><p>Validate the content of all incoming messages, ensuring
communications are secured (i.e. encrypted) and apply threat protection
policies (e.g. Injection and throttling).</p></li>
</ol>
<h1 id="usage-patterns">Usage Patterns</h1>
<blockquote>
<p>Different API usage patterns require different authentication and
authorisation models, below is a short definition of each of the
different usage patterns.</p>
<p>Note: The Security components defined in the following diagrams are
located, for simplicity, in the “trusted” zone i.e. an area managed by
an agency. It is possible that these components could reside in
different zones which relate to varying levels of trust (e.g. a
DMZ).</p>
</blockquote>
<h2 id="pattern-1-internal-use-only">Pattern 1: Internal Use only</h2>
<blockquote>
<p>In this pattern an API is developed for internal use only by agency
applications/systems.</p>
</blockquote>
<p><img src="media/image9.png" style="width:5.21827in;height:3.15843in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234867" class="anchor"></span>Figure 15: Internal API
Security</p>
<blockquote>
<p>We see there is the need to authenticate and authorise the internal
use to the internal application and implement protection between the
internal application and the API on the API Gateway.</p>
</blockquote>
<h2 id="pattern-2-identifying-an-application-developer">Pattern 2:
Identifying an Application Developer </h2>
<blockquote>
<p>When an API is released for external use, the first interaction will
be with App Developers who want to try the API out. This will normally
be via the API Developer Portal.</p>
</blockquote>
<p><img src="media/image10.png"
style="width:5.90139in;height:2.75556in" /></p>
<p><span id="_Toc74234868" class="anchor"></span>Figure 16: Developer
Authentication to API Access</p>
<blockquote>
<p>The Application Developer needs to be authenticated to the API
Developer Portal to register their new application and attain the
relevant credentials which are used to secure interactions with the new
application during development. The developer has to agree to the
conditions of use and subsequent usage of the API can then be traced via
the API keys (see Identify a Consuming Application below).</p>
</blockquote>
<h2 id="pattern-3-anonymous-consuming-application">Pattern 3: Anonymous
Consuming Application</h2>
<blockquote>
<p>This pattern applies when the API provider does not need to know
which consuming applications are using their APIs.</p>
</blockquote>
<p><img src="media/image11.png" style="width:5.85203in;height:2.07072in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234869" class="anchor"></span>Figure 17: Unidentified
Consuming Application</p>
<blockquote>
<p>The consuming application is unidentified (e.g. has no API Key) but
can still use the API.</p>
</blockquote>
<h2 id="pattern-4-identifying-a-consuming-application">Pattern 4:
Identifying a Consuming Application</h2>
<blockquote>
<p>This pattern applies when the API provider needs to know which
consuming applications are using their APIs (for communication, logging
and analytics purposes).</p>
</blockquote>
<p><img src="media/image12.png"
style="width:5.90139in;height:2.09444in" /></p>
<p><span id="_Toc74234870" class="anchor"></span>Figure 18: Consuming
Application Identification</p>
<blockquote>
<p>The consuming application is authenticated (e.g. API Key, Client
Secret etc.) to use the API, but this is only used as a means of
identification or registration.</p>
</blockquote>
<h2
id="pattern-5-authorising-a-system-to-system-interaction-b2b">Pattern 5:
Authorising a System to System Interaction (B2B)</h2>
<blockquote>
<p>The system to system model is where an API is being used to enable
information sharing or integration with an external system e.g. a
partner agency gaining access to supporting information.</p>
</blockquote>
<p><img src="media/image13.png" style="width:5.89583in;height:2.28125in"
alt="B2B" /></p>
<p><span id="_Toc74234871" class="anchor"></span>Figure 19: System to
System Authorisation</p>
<blockquote>
<p>In this model the aim is to ensure that only the correct consuming
system has access to the API, and that the API is protected from
malicious use. Business to business (B2B) models often carry sensitive
information, so the consuming system needs to be authenticated to the
provider for authorised access, confidentiality and integrity.</p>
</blockquote>
<h2 id="pattern-6-authorising-a-consuming-application">Pattern 6:
Authorising a Consuming Application </h2>
<blockquote>
<p>Here the pattern covers the case where different external consuming
applications may be granted different levels of access to resource(s).
The application’s access is not dependent on which customer is currently
using the application, but on which application is using the API e.g.
perhaps the developer for Application A pays a fee so Application A gets
a different quality of service from the API than Application B.</p>
</blockquote>
<p><img src="media/image14.png"
style="width:5.90139in;height:3.27778in" /></p>
<p><span id="_Toc74234872" class="anchor"></span>Figure 20: Consuming
Application Authorisation</p>
<blockquote>
<p>The consuming applications must be authenticated and authorised
before accessing the API. This is normally enforced at the API
gateway.</p>
</blockquote>
<h2 id="pattern-7-authorising-a-customer-delegated-authority">Pattern 7:
Authorising a Customer (Delegated Authority)</h2>
<blockquote>
<p>In this pattern, external consuming applications may be granted
different access to resource(s) depending on which customer is currently
using the application e.g. learner authorises a mobile application to
retrieve their own record of achievement.</p>
</blockquote>
<p><img src="media/image15.png"
style="width:5.90139in;height:2.03819in" /></p>
<p><span id="_Toc74234873" class="anchor"></span>Figure 21: Delegated
Authority</p>
<blockquote>
<p>The customer authenticates to the device. The device and/or the
application is already authorised to use the API. The customer logs in
and authorises the device and/or application to access their
information. E.g. an internet banking application.</p>
</blockquote>
<h2 id="pattern-8-decoupled-flow---ciba">Pattern 8: Decoupled Flow -
CIBA </h2>
<h2 id="client-initiated-backchannel-authentication">(Client Initiated
Backchannel Authentication)</h2>
<blockquote>
<p>In the traditional flow the end user is redirected to an
authentication page, in this pattern the authentication and consent
process is delegated to an authentication device of the end user. This
process is performed via a back channel with a request and response.
This flow decouples the authentication device from the traditional
flow.</p>
<p>In this model the client can initiate the authentication, and
consent, of an end-user via an out-of-band mechanism.</p>
</blockquote>
<p><img src="media/image16.png" style="width:5.90139in;height:2.58542in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234874" class="anchor"></span>Figure 22: Decoupled
Flow</p>
<h2 id="quick-reference-table">Quick Reference Table</h2>
<p>The following table provides a quick reference to identify the most
appropriate authentication and authorisation model to use for the
patterns defined above. The models are explained in detail in subsequent
sections.</p>
<table style="width:100%;">
<colgroup>
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 2%" />
<col style="width: 2%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 6%" />
<col style="width: 3%" />
<col style="width: 4%" />
<col style="width: 4%" />
<col style="width: 6%" />
<col style="width: 4%" />
<col style="width: 3%" />
<col style="width: 4%" />
<col style="width: 6%" />
</colgroup>
<thead>
<tr class="header">
<th rowspan="3">OAuth 2.0 properties</th>
<th colspan="2"></th>
<th colspan="15">Vendor or Internally Developed API Gateway
Capability</th>
</tr>
<tr class="odd">
<th rowspan="2">Mutual TLS (Certificates)</th>
<th rowspan="2">API Keys</th>
<th colspan="11">OAuth 2.0 Grant Types</th>
<th colspan="3">OpenID Connect</th>
<th></th>
</tr>
<tr class="header">
<th>Client Credentials</th>
<th colspan="2">Resource Owner Password Credentials</th>
<th colspan="4">Authorisation Code</th>
<th colspan="3">Implicit</th>
<th>Client Initiated Backchannel Authentication (CIBA)</th>
<th colspan="3">Hybrid</th>
<th>API Gateway Proprietary</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OpenID Connect Scope</td>
<td>n/a</td>
<td>n/a</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td colspan="2">N</td>
<td colspan="2">Y</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>n/a</td>
</tr>
<tr class="even">
<td>Response type</td>
<td>n/a</td>
<td>n/a</td>
<td>n/a</td>
<td>n/a</td>
<td>n/a</td>
<td colspan="2">Code</td>
<td colspan="2">code</td>
<td>Token</td>
<td>Id_token</td>
<td>Id_token token</td>
<td>n/a</td>
<td>Code id_token</td>
<td>Code Token</td>
<td>Code id_token token</td>
<td>n/a</td>
</tr>
<tr class="odd">
<td>PKCE</td>
<td>n/a</td>
<td>n/a</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>n/a</td>
</tr>
<tr class="even">
<td colspan="18"><strong>API Usage Patterns</strong></td>
</tr>
<tr class="odd">
<td>Pattern 1: Internal Use Only</td>
<td>✔</td>
<td></td>
<td></td>
<td>✔</td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr class="even">
<td>Pattern 2: Identifying an Application Developer</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
</tr>
<tr class="odd">
<td>Pattern 3: Anonymous Consuming Application</td>
<td></td>
<td>✔</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr class="even">
<td>Pattern 4: Identifying a Consuming Application</td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr class="odd">
<td>Pattern 5: Authorising a System to System Interaction (B2B)</td>
<td>✔</td>
<td>✔</td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr class="even">
<td>Pattern 6: Authorising a Consuming Application</td>
<td></td>
<td>✔</td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>✔</td>
</tr>
<tr class="odd">
<td>Pattern 7: Authorising a Customer (Delegated Authority)</td>
<td></td>
<td>✔</td>
<td></td>
<td>✔</td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td>🗶</td>
<td></td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
<td>✔</td>
</tr>
<tr class="even">
<td><p>Pattern 8:</p>
<p>Decoupled Flow (CIBA)</p></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><p>✔</p>
<p><strong>Recommended</strong></p></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234994" class="anchor"></span>Table 10: Quick
Reference Table</p>
<blockquote>
<p>The initial consideration for any API Security Framework should be to
use the Authorisation Code Grant Type, the following points provide
pointers for agencies when considering their requirements:</p>
</blockquote>
<ol type="1">
<li><p>It is good practice to use API Keys as the basis of all
system-to-system authentication, such as consuming applications to
API.</p></li>
<li><p>For the Authorise Consuming Application usage pattern, the
<strong>Client Credentials Grant Type</strong> is recommended but the
<strong>API Keys</strong> model can be used instead.</p></li>
<li><p>For the Customer Authorisation usage pattern</p>
<ul>
<li><p>the <strong>Authorisation Code Grant Type</strong> is recommended
where the customer is the Resource Owner, the provider (agency) controls
the Resource Server, but the Authorisation server is not owned by the
provider or is elsewhere within the provider organisation</p></li>
<li><p>Where there is a strong desire to not interrupt the customer’s
experience with the consuming application, use of <strong>Client
Initiated Backchannel Authentication</strong> is appropriate.</p></li>
<li><p>the <strong>Resource Owner Password Credentials Grant
Type</strong> is appropriate where the customer is the Resource Owner,
the provider (agency) controls the Resource Server, and the API Gateway
is the OAuth 2.0 Authorisation Server</p></li>
</ul></li>
<li><p>Use of solely <strong>API Keys</strong> for Customer
Authorisation is only appropriate as a last resort</p></li>
<li><p>For the Internal Use Only usage pattern, <strong>the
Authorisation Code Grant Type</strong> is recommended, where practical.
Otherwise, it may be appropriate to leverage the provider agency’s
existing internal authentication and authorisation providers</p></li>
<li><p>For the <strong>Developer Authentication</strong> usage pattern,
it is appropriate to leverage (or build) the capabilities of the
developer portal (e.g. username and password).</p></li>
<li><p>The <strong>Decoupled flow (CIBA)</strong> supports out-of-band
authentication and consent approval. It is recommended for organisations
that want to enable push notification for web-based services and
applications.</p></li>
<li><p>The <strong>Authorisation Code Grant Type</strong> has been
enhanced with <strong>PKCE</strong> (Proof of Key for Code Exchange) and
addresses key security hacks. In OAuth 2.1 (draft) it is now recommended
as a default option for <strong>Authorisation Code Grant
Type.</strong></p></li>
</ol>
<h1 id="api-authentication-authorisation-basics">API Authentication
&amp; Authorisation Basics</h1>
<blockquote>
<p>Before looking at the technical solutions to API authentication and
authorisation, this section will provide an introduction that
illustrates the situations where authentication and authorisation are
appropriate.</p>
<p>Authorisation and authentication are intrinsically linked inside the
OAuth 2.0 framework which in itself is regarded as synonymous with
securing APIs. OAuth 2.0 uses its own terminology which is worth
becoming familiar with when adopting an OAuth 2.0 approach.</p>
<p>As the OAuth 2.0 framework is a commonly accepted approach to the
securing of modern APIs (large companies like Google, Microsoft and
Twitter use it), this section also covers an introduction to OAuth
2.0.</p>
</blockquote>
<h2 id="authentication">Authentication</h2>
<p><strong><span class="smallcaps">Required</span></strong></p>
<p>When securing APIs, authentication is required to identify the
consumers and/or consuming applications that want to access or consume
an API. Authentication enables the API provider to identify all
consumers of an API and to confirm that the consumer requesting access
is who they say they are. This doesn’t automatically authorise them to
access the APIs or the underlying resources.</p>
<p>Providers should define a registration process for each category of
consumer, whether system or human.</p>
<p>The ability of knowing who is using an API cannot be overstated. This
is critical when it comes time to implement aspects of the API service
lifecycle, such as service deprecation, or notification of an outage. It
also enables the API provider to implement different service levels for
different consumers. E.g. commercial customers might have a higher
request limit per day than customers not paying for the service.</p>
<p>Making application developers register for use of the API also means
they must sign up to terms and conditions that define how they might use
the data they get from the API, and that they agree to ensure that their
consuming applications will behave in an acceptable and non-abusive
manner.</p>
<h3 id="authentication-techniques">Authentication Techniques</h3>
<blockquote>
<p>The diagram below lists the authentication techniques that can be
used to secure APIs and Appendix B - Authentication provides guidance on
when to use them.</p>
</blockquote>
<p><img src="media/image19.png"
style="width:5.90522in;height:3.95833in" /></p>
<p><span id="_Toc74234875" class="anchor"></span>Figure 23:
Authentication Options</p>
<blockquote>
<p>There is a second Security Token option that is built on SAML, but it
is only recommended if SAML is already in place within a particular
sector (For example Education), otherwise SAML is seen as a deprecated
model for REST APIs.</p>
<p>This document does not cover the SAML option but the following link
detail how SAML is used as an authentication token in OAuth 2:</p>
<p><u>Security Assertion Mark-up Language (SAML) 2.0 Profile for OAuth
2.0 Client Authentication and Authorization Grants</u></p>
</blockquote>
<h2 id="oauth-2.0-basics">OAuth 2.0 Basics<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a></h2>
<blockquote>
<p>OAuth 2.0 provides a more comprehensive and extensible approach to
security than some of the basic authentication and authorisation
mechanisms. Based on security tokens, it can be used for delegated
authority such as enabling a mobile application to act on behalf of its
user.</p>
<p>The IT industry perceives the need for any production quality API
security framework to be based on OAuth 2.0. In reality OAuth 2.0 is a
delegated authorisation framework, but it provides the
<strong><u>foundations</u></strong> on which secure services can be
built in order to provide the complete security solution.</p>
<p>OAuth 2.0 requires some fundamental security components in order to
work, and has its own terminology for describing these components and
their roles:</p>
</blockquote>
<p><img src="media/image20.png"
style="width:4.07228in;height:2.78258in" /></p>
<p><span id="_Toc74234876" class="anchor"></span>Figure 24: OAuth 2.0
Components</p>
<ol type="1">
<li><p><strong>Resource Owner</strong> – the person who has the right to
grant a third party (e.g. a consuming application) access to a protected
resource (e.g. information about themselves). Quite often the resource
owner is the customer.</p></li>
<li><p><strong>Client (or Client Application)</strong> – A consuming
application requesting access to a protected resource on behalf of a
third party e.g. a mobile application on a user’s (third party)
smartphone or a web application accessed via a browser.</p></li>
<li><p><strong>OAuth Server / Authorisation Server</strong> provides a
Security Token Server / Infrastructure for managing tokens. It is
responsible for issuing:</p>
<ul>
<li><p>Authorisation (code) grant – approval tokens driven by Resource
Owner approval</p></li>
<li><p>Access tokens used by the API to authorise access</p></li>
<li><p>Refresh tokens which allow new access tokens to be requested by
the client and re-issued within a specified timeframe</p></li>
</ul></li>
<li><p><strong>Authentication Server</strong> – This is not a component
of OAuth 2.0, or defined by OAuth 2.0, but needs to be considered when
defining a complete OAuth 2.0 framework. This could be a simple login
capability or managed by an Identity Service Provider.</p></li>
<li><p><strong>Resource Server</strong> – This hosts the protected
resources (APIs &amp; backend applications) which only allow
authenticated and authorised clients by:</p>
<ul>
<li><p>Checking the access token in each incoming API request</p></li>
<li><p>Validating the access token against the Authorisation Server and
the permitted access rights</p></li>
</ul></li>
</ol>
<blockquote>
<p>OAuth 2.0 comes with four types of grant flows (how Client
Applications can gain Access Tokens), each appropriate to different
situations and solution requirements:</p>
</blockquote>
<ul>
<li><p>Client Credentials</p></li>
<li><p>Resource Owner Password Credentials</p></li>
<li><p>Authorisation Code</p></li>
<li><p>Implicit</p></li>
</ul>
<blockquote>
<p>OAuth 2.0 is appropriate where there is a requirement for third party
applications to access restricted resources. This should help mitigate
the risks relating to:</p>
</blockquote>
<ul>
<li><p>Third party applications storing user credentials (username and
password)</p></li>
<li><p>Resource servers having to support user stores and password
authentication</p></li>
<li><p>Resource owners not being able to define granular access to
resources, including duration</p></li>
<li><p>Revoking credentials that are compromised</p></li>
</ul>
<blockquote>
<p>The following two sections (Resource Based Scopes (Scopes) and Proof
Key for Code Exchange (PKCE)) are two additional concepts that should be
clearly understood, and they provide additional security controls. Also,
PKCE is seen as a security control that will be mandated in future
versions of the OAuth 2 specification.</p>
</blockquote>
<h3 id="resource-based-scopes-coarse-grained-access">Resource Based
Scopes (Coarse Grained Access)</h3>
<blockquote>
<p>Access and Refresh Tokens provide confirmation that the end-user has
consented to delegate access rights to the client. Scopes, which are
linked to the Access Token, provided an additional level of
authorisation, each one defining a specific capability for example
“read” document or “write” document.</p>
<p>Scopes are approved by the end user and enforced by the backend API.
The authorisation server validates the token, which contains the scopes
that have been consented to, and validates the client is not exceeding
its access rights.</p>
</blockquote>
<h3 id="pkce-proof-key-for-code-exchange">PKCE (Proof Key for Code
Exchange)</h3>
<blockquote>
<p>The Authorisation Code Grant Type is regarded as the recommended
solution for most scenarios and is regarded as one of the most secure
options especially or server-side applications, where the final access
token required to call the Resource APIs is protected via an encrypted
channel between the Authorisation Server and the Client Application
(residing on a server)</p>
<p>To obtain the access token the client application makes an
authorisation request to the Authorisation Server and if the required
information is provided and approved the Authorisation Server presents
the Client application with a Code that is then used to request the
access token over the secure back channel.</p>
<p>The back-channel link is normally secured using MTLS, but the initial
flow to obtain the code token is over TLS and in certain architectures
can be intercepted in a Man in the Middle attack.</p>
<p>Proof of Key for Code Exchange (PKCE) was developed specifically to
address this, which is called the ”Authorisation Code Interception
Attack”, and in particular for mobile phone scenarios where malicious
application (with elevated rights) could also be installed on the same
mobile device as the client application and obtains the code, and with
this then obtain the access token.</p>
<p>It works based on a random key (code verifier) that is generated,
only known by the Client and is used to create another random key, based
on a hashing method, which is called the code challenge.</p>
<p>The challenge is sent (including the method) during the code flow and
is stored by the authorization server.</p>
<p>When the client requests the token with the code token, it also
includes the original code verifier, which the authorisation server
validates against the code challenge before the Access Token is returned
to the client.</p>
</blockquote>
<h2 id="basic-oauth-2.0-implementation-patterns">Basic OAuth 2.0
Implementation Patterns</h2>
<blockquote>
<p>There are three primary implementation patterns:</p>
</blockquote>
<ol type="1">
<li><p>Client Credential Grant Flow</p></li>
<li><p>Authorisation Code Grant Flow</p></li>
<li><p>Distributed Resource and Authorisation Servers</p></li>
</ol>
<p><img src="media/image21.png" style="width:5.78889in;height:2.51875in"
alt="A picture containing shape Description automatically generated" /></p>
<p><span id="_Toc74234877" class="anchor"></span>Figure 25: OAuth 2.0
Implementation Models</p>
<blockquote>
<p>As can be seen above, in most models the Resource Server resides with
the Authorisation Server. But OAuth 2.0 also supports a distributed
model, if needed, where the Resource Server and Authorisation Server are
separate.</p>
<p>By adding an Authentication Server component into the API Security
Framework, a number of additional implementation models can be
considered. The models above have separate Authentication servers e.g.
external Identity Service Providers, Google, RealMe etc. and internal
Authorisation services.</p>
<p>These Authentication Services could be housed on the same system as
the Authorisation and Resource Server, and can, as would be expected,
simplify the Security architecture.</p>
</blockquote>
<p><img src="media/image22.png" style="width:5.80786in;height:2.52736in"
alt="A picture containing diagram Description automatically generated" /></p>
<p><span id="_Toc74234878" class="anchor"></span>Figure 26: OAuth 2.0
Models (co-location of Authorisation &amp; Authentication Services)</p>
<h3 id="distributed-model---user-managed-access-uma">Distributed Model -
User Managed Access (UMA)</h3>
<blockquote>
<p>The Distributed Models allows for multiple Resource Servers and
Authorisation Servers and is addressed by the User Managed Access (UMA)
model, which is driven by the Kantara initiative<a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a> and
currently has been productionised by a number of vendors<a href="#fn5"
class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>.</p>
<p>UMA is a delegation access model allowing 3<sup>rd</sup> Parties to
have temporary access to resources that are approved (consented to) by
the resource owner.</p>
<p>The resource owner has the ability to provide predefined policies
that define the relationship and access controls for all their resources
across multiple Resource Servers of what can be accessed and by whom
(i.e. minimise their interaction in the current OAuth approval process)
and provides a central point of control</p>
<p>A centralised UMA Authorisation Server then keeps track of all
Resource Servers associated with a given Resource Owner.</p>
</blockquote>
<p><img src="media/image23.png" style="width:3.92138in;height:4.40005in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234879" class="anchor"></span>Figure 27: User Managed
Access</p>
<blockquote>
<p>The Resource Owner establishes a token-based trust relationship
between the Resource Server and the Authorisation Server.</p>
<p>The Resource Owner also defines the access control policies which
grant access to potential consumers. A client application, driven by the
Requesting Party who is requesting access to resources owned by the
Resource Owner, attempts to access a resource on a Resource Server but
will be redirected to the UMA Authorisation Server.</p>
<p>The client application has to obtain a client key, client secret and
access token from the UMA Authorisation Server before trying to get to
the required resource on the Resource Server. The Resource Server will
validate the access token and the permitted level of access with the
Authorisation Server before allowing the client application to consume
its required resources.</p>
<p>The UMA Authorisation Server offers two APIs to support these
interactions:</p>
</blockquote>
<ul>
<li><p>Protection API – used by Resource Servers for getting
authorisation-request tokens and validating access tokens</p></li>
<li><p>Authorisation API – used by the Client Application to obtain a
token for accessing a specific resource</p></li>
</ul>
<blockquote>
<p>OAuth 2.0 provides a consent model that is driven via a synchronous
process, UMA provides enhance consent capability that is driven via
asynchronous processes, that allows for:</p>
</blockquote>
<ol type="1">
<li><p>The sharing of information with parties and groups based on
relationships</p></li>
<li><p>Manage request from 3rd Parties</p></li>
<li><p>Monitor Shares across sources</p></li>
</ol>
<h2 id="openid-connect">OpenID Connect</h2>
<h3 id="basic-principles">Basic Principles</h3>
<blockquote>
<p>OpenID Connect is the recommended security profile for the use of
OAuth 2.0 authentication security tokens when an API requires more
secure authentication than offered solely by API keys e.g. when data is
a two-way flow between the consuming application and the API.</p>
<p>OpenID Connect is used to:</p>
</blockquote>
<ol type="1">
<li><p>Enhance the process and user experience during the onboarding
process</p></li>
<li><p>Provide an SSO capability</p></li>
<li><p>Secure transfer of user data</p></li>
<li><p>Enrich the user experience</p></li>
<li><p>Provides a trust framework [integrity] for Service and Identity
Providers to share consented user data</p></li>
</ol>
<blockquote>
<p>During the authorisation token exchange process a level of
authentication is required. The authentication process is limited to
what authentication services the authorisation server can support. For
example, the Resource Owner authorisation process is normally supported
out of the box by the authorisation server, using username and
password.</p>
<p>These authentication services can be enhanced with authentication
security tokens by implementing the OpenID Connect OAuth profile. For
customers and internal users this can be achieved using a brokered or
federated service.</p>
<p>Federation in the context of API security provides the ability to
re-use user identities in an SSO way by providing a trust relationship
between the Identity Service Provider (Open ID Connect service) and the
Authorisation Server. This establishment of trust between the Identity
Provider and Authorisation Server is normally established using
certificates and mutual authentication. All communication must be over
TLS/MTLS to provide Confidentiality and Integrity controls.</p>
<p>OpenID Connect runs on top of OAuth 2.0 and is a lightweight RESTful
framework for identity service interaction, to provide authorisation
services. It allows claims (or attributes) about a user to be shared in
a secure manner from an identity provider to the client application with
the explicit consent of the user.</p>
<p>OpenID Connect uses all the flows, grant types and endpoint exposed
by OAuth 2.0, and it add the following additional capabilities to
provide access to the users claims / attributes:</p>
</blockquote>
<ol type="1">
<li><p>An ID Token</p></li>
<li><p>A Userinfo endpoint</p></li>
</ol>
<blockquote>
<p>The ID Token is a JSON Web Token (JWT) that contains authenticated
user information (and attributes) that the authorisation (OAuth 2.0
Server) / authentication server (OpenID Connect Server) provides to the
client application.</p>
<p>This token can then be used to enforce finer grained access controls
by providing additional attributes that can be used by the authorisation
server to apply these policies.</p>
<p>The “new” JWT token has to be signed in order to address
confidentiality and integrity requirements. There are also additional
parameters (relates to code, session and access token hashes) defined
that have been added to help address replay attacks.</p>
<p>The Userinfo endpoint can be called with the required access token to
also obtain the same claims/ attribute (e.g. first name) provided in the
ID Token</p>
<p>To address the risk of forged or stolen assertions, it is recommended
that all communication is over TLS and tokens are at a minimum signed
for authentication</p>
</blockquote>
<h3 id="openid-connect-grant-flows">OpenID Connect Grant Flows</h3>
<blockquote>
<p>OpenID Connect builds on the existing OAuth 2.0 grant flows, and once
implemented it is enacted using a specific scope (openid) in the initial
authorisation call that the client makes to the OpenID Connect
service.</p>
<p>There are a number of additional scopes that OpenID Connect
introduces (e.g. profile) that detail specific attributes (e.g. name)
that can be presented in the ID token. So, for example a Client might
request the profile information, but it is the Identity Provider that
details what this will provide (e.g. first and last name, phone and
email address) and this has to be consented (via the OAuth 2 consent
process) to by the user.</p>
<p>The request call also includes a response type which allows the
application developer to request identity information tokens and
security tokens depending on what information they want back, the type
of client (e.g. Server/ Client based). The link below provides an
excellent summary of the response type possible with OpenID Connect.</p>
<p><a
href="https://darutk.medium.com/diagrams-of-all-the-openid-connect-flows-6968e3990660">https://darutk.medium.com/diagrams-of-all-the-openid-connect-flows-6968e3990660</a></p>
<p>The ID Token not only includes identity information it also includes
additional technical claims which allows the Client application to
verify that the ID Token is valid and came from the Identity Provider.
It is highly recommended that a Client validates the ID token (e.g.
signature, client ID and issuer). The ID token can also be encrypted to
enhance the confidentiality and integrity of the information
presented.</p>
<p>OpenID Connect works with all the existing OAuth 2.0 grant types and
adds additional security controls to the Authorisation Code grant flow,
for the implicit flow in OAuth 2.0, which is seen as a less secure flow
than the Authorisation flow and is now being discouraged, OpenID Connect
provides a level of enhancement to the Implicit flow as the nonce and
state are returned in a signed JWT, but this is really only recommended
in login-only use cases.</p>
<p>Finally there is the concept of a Hybrid flow (<a
href="https://openid.net/specs/openid-connect-core-1_0.html#HybridFlowSteps">https://openid.net/specs/openid-connect-core-1_0.html#HybridFlowSteps</a>)
that uses the Authentication code flow as a base and (depending on what
is required by the client and what is enabled by the Authorisation
Server) it allows additional tokens (ID Tokens) to be issued during the
flow. These are both used to provide secure identity information and
also additional confidentiality and integrity controls relating to
state, nonce values and hashes.</p>
<p>A good example of where the Hybrid flow is being mandated is in the
management of consent in the Open Banking Consumer Data Rights
specifications. (https://cdr-register.github.io)</p>
</blockquote>
<h3 id="openid-connect-patterns">OpenID Connect Patterns</h3>
<blockquote>
<p>In the first OpenID Connect pattern detailed in Figure 28, the
Authentication and Authorisation Servers are conceptually hosted on
different physical servers (the OpenID Connect server can be internal or
external to the organisation). The user connects to the web application
and is redirected to the OpenID Connect server for authorisation.</p>
<p>Once authorised, the user is redirected to the Web Application which
in turn exchanges the ID Token for an access token.</p>
<p>Note: It is the token flow and exchange that is key to understand in
this model. The Web Application could be an Application/ API Server and
the interface to the authorisation and authentication server managed by
the API Gateway</p>
<p>A trusted link is set up between the OpenID Connect Server and the
OAuth Server (Authorisation Server) which also allows additional
identity information to be provided in a JWT format via the userInfo
endpoint. This is important as the token exchange can result in the loss
of user data that is required to provide fine grained access.</p>
<p>If the OpenID Connect server was external, it would be the API
Gateway that would be responsible for the interface and token exchange
process.</p>
</blockquote>
<p><img src="media/image24.png"
style="width:5.90139in;height:3.40694in" /></p>
<p><span id="_Toc74234880" class="anchor"></span>Figure 28: OpenID
Connect - Distributed Authorisation &amp; Authentication Server</p>
<blockquote>
<p>The application has to exchange the ID Token for an Access Token in
this pattern.</p>
<p>In the second pattern (below) the OpenID Connect server is run on the
same server as the OAuth Authorisation server, so the ID Token and the
Access Token can be issued at the same time. In both models the OpenID
Connect Server can use LDAP for its back-end User Store, to provide
authorisation for internal users.</p>
</blockquote>
<p><img src="media/image25.png"
style="width:5.90139in;height:3.00972in" /></p>
<p><span id="_Toc74234881" class="anchor"></span>Figure 29: OpenID
Connect &amp; OAuth</p>
<blockquote>
<p>One other model is for an external OpenID Connect pattern, where the
OpenID Connect server is an external Identity Provider (e.g. AoG
service) and the API Gateway is responsible for managing the token
exchange, potentially also housing the Authorisation Server.</p>
</blockquote>
<h3 id="heart-working-group">Heart Working Group</h3>
<blockquote>
<p>The OpenID Foundation uses working groups (<a
href="https://openid.net/wg/"><u>https://openid.net/wg/</u></a> ) to
focus on specific problems, technology or specific marketplace sectors
like FAPI (Financial-Grade APIs) or the Health sector HEART Working
group.</p>
<p>HEART (Health Relationship Trust <a
href="https://openid.net/wg/heart/"><u>https://openid.net/wg/heart/</u></a>
)defines a set of profiles that enables patients to control how, when,
and with whom their clinical data is shared.</p>
<p>It also defines the interoperable process for systems to exchange
patient-authorized healthcare data consistent with open standards,
specifically FHIR (Fast Healthcare Interoperability Resources), OAuth,
OpenID Connect, and UMA (User-Managed Access).</p>
<p>Two pertinent specifications are:</p>
<p><strong>Health Relationship Trust Profile for User-Managed Access
2.0</strong></p>
<p><a
href="https://openid.net/specs/openid-heart-uma2-1_0.html"><u>https://openid.net/specs/openid-heart-uma2-1_0.html</u></a></p>
<p><strong>Health Relationship Trust Profile for Fast Healthcare
Interoperability Resources (FHIR) UMA 2 Resources</strong></p>
<p><a
href="https://openid.net/specs/openid-heart-fhir-uma2-1_0.html"><u>https://openid.net/specs/openid-heart-fhir-uma2-1_0.html</u></a></p>
</blockquote>
<h3 id="ciba-flow">CIBA Flow</h3>
<blockquote>
<p>The OpenID Connect “Client Initiated Backchannel Authentication” flow
is important because it adds three “decoupled” authorisation flows.
Instead of using redirects through the browser, this model allows a
user’s mobile device to be decoupled from the flow, and the client
application, and act as an authentication device on which the user
authentication and the consent confirmations are performed.</p>
<p>The important point here is the client application and authorisation
application/service do not have to run on the same device (e.g.
smartphone) or be linked.</p>
<p>In the CIBA flow the initial authorisation call is made to the new
(OAuth2) backchannel authentication endpoint,</p>
<p>and the authorisation server then delegates the authentication and
consent approval tasks to the authentication device (smartphone) of the
user, who will accept or deny the request.</p>
<p>The access token being sent to the client is managed by one of three
flows:</p>
</blockquote>
<ol type="1">
<li><p>Poll – The client polls the Authorisation Server until the
authorisation server has received the approval from the authentication
device.</p></li>
<li><p>Ping – The client waits until it is notified by the Authorisation
Server and then it requests the token</p></li>
<li><p>Push – The Authorisation server, when it receives approval from
the authentication device pushed the Access, ID Token and Refresh token
to the client</p></li>
</ol>
<h2 id="authorisation">Authorisation</h2>
<p><strong><span class="smallcaps">Required</span></strong></p>
<blockquote>
<p>Authorisation is the act of performing access control on a resource.
Authorisation doesn’t just cover the enforcement of access controls, but
also the definition of those controls. This includes the access rules
and policies, which should define the required level of access agreeable
to both provider and consuming application. The foundation of access
control is a provider granting or denying a consuming application and/or
consumer access to a resource to a certain level of granularity.</p>
<p>In the Authentication section the concepts of OAuth were introduced,
and a number of Authentication patterns were defined. This section
focuses on Authorisation and provides additional patterns that work with
OAuth or provides an alternative.</p>
</blockquote>
<h3 id="authorisation-techniques">Authorisation Techniques</h3>
<blockquote>
<p>Authentication on its own does not necessarily provide permissions to
access an API or application. It merely validates that you are who you
say you are. If it is used for access control, it is an all or nothing
control mechanism (e.g. administration account).</p>
<p>Once a user is authenticated (e.g. using username and password), an
authorisation process will grant (or deny) them the right to perform an
action or access to information. Normally this authorisation process is
applied using either a coarse grained or fine-grained access control
process.</p>
<p>The normal model is to provide coarse grained access at the API or
API Gateway request point, and fine-grained control at the backend
services, but this model is changing as backend systems become more
modular (e.g. microservices) and less monolithic. This will result in a
need for fine grained authorisation support at the request point.</p>
<p>With this understanding, the two types of authorisation that will be
considered are defined in Figure 32.</p>
<p>This covers:</p>
</blockquote>
<ol type="1">
<li><p>Role- or Group-based authorisation - where membership in a role
or group determines access rights for the consumer</p></li>
<li><p>Policy- or Attribute-based authorisation - where characteristics
of the consumer are evaluated to determine access rights for the
consumer</p></li>
</ol>
<p><img src="media/image26.png" style="width:5.90139in;height:1.64583in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234882" class="anchor"></span>Figure 30:
Authorisation Techniques</p>
<blockquote>
<p>The API Gateway will provide this support either using OAuth 2.0 or
its own proprietary capability.</p>
</blockquote>
<h3 id="roles-based-access-controls-rbac">Roles Based Access Controls
(RBAC)</h3>
<blockquote>
<p>In many organisations Active Directory provides the authentication
services for users. Active Directory groups are then used to provide
authorisation. This is classed as Discretionary Access Control (DAC):
access to systems is granted by applying Access Control Lists (ACLs)
directly to the user, or to the groups in which users reside.</p>
<p>Note: LDAP directories can also provide this service, and in many
organisations are used to provide the same service AD delivers but for
external users.</p>
<p>Active Directory (or LDAP) Groups are synonymous with roles and can
be used to provide coarse-grained authorisation for APIs.</p>
</blockquote>
<h4 id="scopes-limited-fine-grain-access">Scopes (Limited Fine Grain
Access) </h4>
<blockquote>
<p>Based on the services (APIs) that are exposed, additional access
controls can be applied using scopes. For example, a data service might
provide “read” and “write” scopes which could be granted to a user based
on the AD groups they were in.</p>
<p>When the “Authorisation code” token is passed to the Authorisation
Server a scope parameter is included to define what scopes the client
can use. Scopes can be used to limit the authorisation granted to the
client by the resource owner. These scopes are defined by the client
application developer. This is an important consideration as it can
impact how the API service is defined e.g. single service with multiple
scopes or multiple services with single scopes. The developer has to
ensure that the minimum privileges are granted to client applications to
carry out the tasks (exposed by the Client Application and APIs) the
user wishes the application to complete.</p>
<p>Scopes provide a level of coarse/fine grained access and represent
specific access rights e.g. the ability to read a document or write a
new document (or both) is limited by the Access Token.</p>
<p>Scopes can be used alone to define coarse/fine grained access, but
these scopes need to be defined and built into the Client application /
API being built. Consideration is needed to understand (for example)
if:</p>
</blockquote>
<ul>
<li><p>a single scope protects the service</p></li>
<li><p>scopes are defined to protect fine-grained business
functionality</p></li>
<li><p>services should be divided into many smaller services with one
scope each</p></li>
</ul>
<blockquote>
<p>Once the token is issued to a client application, the access rights
bound by the scope are encapsulated in the Access Token for the length
of its validation period.</p>
<p>A client application may invite a user to authorise the application
to act on behalf of the user. Using NZBN as an example, the client
application (an accounting application for example) may invite a user to
authorise the client application to update primary business data on the
user’s behalf. The application may ask “Do you want [client application]
to be able to update your business information on the NZBN Directory?”.
Assuming the user grants the client application this privilege, the
authorisation token returned by the API will have a scope that enables
update access. This scope is represented by an identifier. For example,
the NZBN update scope looks like this:</p>
<p>https://api.nzbn.govt.nz/auth/pbd.readwrite</p>
<p>whereas a read-only scope would be:</p>
<p>https://api.nzbn.govt.nz/auth/pbd.core.readonly</p>
</blockquote>
<h3 id="attribute-based-access-controls">Attribute Based Access
Controls</h3>
<blockquote>
<p>Attribute-based access control (ABAC) defines an access control
process whereby access is granted based on policies that are built using
attributes e.g. a policy might state that access to a specified resource
is only permitted for users who are in Sales or Marketing, who are
managers, during office hours only. ABAC provides fine grain
authorisation services.</p>
<p>The really important control that ABAC provides is the ability to
provide context when applying access controls, e.g. access decisions can
be based on the IP address of the device, the operating system of the
client and the last known transactions of a client.</p>
<p>The recognised standard for ABAC is XACML, which is an XML
based-language.</p>
</blockquote>
<h3 id="api-gateway">API Gateway</h3>
<blockquote>
<p>API Gateways have been mentioned previously in the context of API
protection. Most API Gateways on the market provide support for OAuth
2.0 and can also provide Authorisation (and Authentication) Services via
a direct connection to:</p>
</blockquote>
<ol type="1">
<li><p>An Identity Store containing groups</p></li>
<li><p>An Identity Access Management system</p></li>
<li><p>A Policy server</p></li>
</ol>
<p><img src="media/image27.png"
style="width:5.45023in;height:2.60307in" /></p>
<p><span id="_Toc74234883" class="anchor"></span>Figure 31: API Gateway
for Authorisation</p>
<h1 id="security-controls">Security Controls </h1>
<blockquote>
<p>This section looks at additional controls that should be considered
and implemented when protecting APIs. The four areas that should be
considered are:</p>
</blockquote>
<ol type="1">
<li><p>Confidentiality</p></li>
<li><p>Integrity</p></li>
<li><p>Availability</p></li>
<li><p>Threat Protection</p></li>
<li><p>Logging and Auditing</p></li>
</ol>
<blockquote>
<p>Depending on the classification of the information that is presented
in the APIs and the Risk Framework applied different access controls
will need to be applied.</p>
<p>Appendix F provides move detail in reference to the security controls
that can be applied.</p>
</blockquote>
<h2 id="confidentiality-and-integrity">Confidentiality and
Integrity</h2>
<blockquote>
<p>Confidentiality and integrity cover the handling of request and
response data, both in transit and at rest. The aim is to protect the
payload content from unauthorised access, manipulation or faking. An API
request needs to be received intact by the API, with validation as to
the source of the request. Untampered API responses need to be received
by the consuming application, with confirmation that they are
legitimately from the API.</p>
</blockquote>
<h2 id="availability-and-threat-protection">Availability and Threat
Protection</h2>
<blockquote>
<p>Availability in this context covers threat protection to minimise API
downtime, looks at how threats against exposed APIs can be mitigated
using basic design principles and how to apply protection against
specific risks and threats.</p>
<p>Availability also covers scaling to meet demand and ensuring the
hosting environments are stable etc. These levels of availability are
addressed across the hardware and software stacks that support the
delivery of APIs. There are no specific standards for availability, but
availability is normally addressed under business continuity and
disaster recovery standards. These standards recommend a risk assessment
approach to define the availability requirements. Further information on
business continuity and risks can be found at Standards New Zealand
website<a href="#fn6" class="footnote-ref" id="fnref6"
role="doc-noteref"><sup>6</sup></a>.</p>
<p>For cloud services, the New Zealand Government ICT website provides
an assessment tool that includes a risk assessment tool which covers
availability, business continuity and disaster recovery related
questions<a href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"><sup>7</sup></a>.</p>
<p>As mentioned in section 1.1.3, there are various types of risk which
impact APIs. This includes threats to availability as well as
confidentiality and integrity. Many threats can be mitigated through
good secure coding practices, using OWASP guidelines, as indicated in
section 1.2.2.</p>
<p>Where the resources being exposed by an API are sensitive i.e. not
public data, it is advisable to perform:</p>
</blockquote>
<ul>
<li><p>Threat assessment – early on in the API development
lifecycle</p></li>
<li><p>Penetration test – once an API is developed and published
(testable)</p></li>
</ul>
<blockquote>
<p>There are also automated vulnerability testing tools which can be
used to give an indication of vulnerabilities in web application
designs.</p>
</blockquote>
<h2 id="logging-and-alerting">Logging and Alerting</h2>
<blockquote>
<p>Traditional logging, alerting and incident management practices also
apply to APIs, along with additional considerations such as:</p>
</blockquote>
<ul>
<li><p>correlating API requests with specific back-end system activity
and the resulting API responses to support end-to-end tracing</p></li>
<li><p>identifying specific API requests from consumers to help resolve
API consumer problems</p></li>
<li><p>detecting events that may indicate a malicious attempt to access
an API</p></li>
</ul>
<h1 id="api-security-use-case">API Security Use Case</h1>
<blockquote>
<p>The illustrative example below demonstrates a sequence of information
exchange events and highlight where security controls are
implemented.</p>
</blockquote>
<h2 id="high-level-view">High Level View</h2>
<blockquote>
<p>This sequence diagram shows the high-level interaction of the actors
and participant service providers.</p>
</blockquote>
<p><img src="media/image28.png" style="width:5.90139in;height:4.31319in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234884" class="anchor"></span>Figure 32: API Security
Use Case High Level View</p>
<h2 id="detailed-level-view">Detailed Level View</h2>
<blockquote>
<p>This sequence diagram shows the detailed interaction of the actors
and participant service providers.</p>
</blockquote>
<p><img src="media/image29.png" style="width:6.37963in;height:5.02908in"
alt="Graphical user interface Description automatically generated with low confidence" /></p>
<p><span id="_Toc74234885" class="anchor"></span>Figure 33: API Security
Use Case Detailed Level View</p>
<ol type="1">
<li><p>Glossary of terms</p></li>
</ol>
<blockquote>
<p>Below is a list of common terms. Terms in the Description column
highlighted in bold are described elsewhere in the Glossary.</p>
</blockquote>
<table>
<colgroup>
<col style="width: 28%" />
<col style="width: 71%" />
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Analytics</td>
<td>Analytics in the context of this document is the capturing and
reporting of API usage.</td>
</tr>
<tr class="even">
<td>Consumers</td>
<td>Customers, API Consuming Applications and Application Developers who
use the API.</td>
</tr>
<tr class="odd">
<td>Consuming Application</td>
<td>This is any application (on any device) that consumes an API.</td>
</tr>
<tr class="even">
<td>Context</td>
<td>Context in this document generally refers to request context. For
example, a JWT Token may contain information about the customer
initiating an API request.</td>
</tr>
<tr class="odd">
<td>Customers</td>
<td>People (or organisations) that use the Consuming Applications to
access the API resources the API Provider is offering.</td>
</tr>
<tr class="even">
<td>Discovery</td>
<td>The ability for Application Developers to find resources and
associated APIs to use in their Consuming Applications</td>
</tr>
<tr class="odd">
<td>API</td>
<td>Application Programming Interface - a piece of software, which
provides a way for other disparate pieces of software (applications,
systems) to talk to one another.</td>
</tr>
<tr class="even">
<td>API Catalogue</td>
<td>The API delivery component that lists the APIs offered, along with
their Interface Specifications and guidance on how to gain access and
use the APIs.</td>
</tr>
<tr class="odd">
<td>API Developer</td>
<td>The organisation (or person) who creates the API and maintains the
Interface Specification for the API.</td>
</tr>
<tr class="even">
<td>API Developer Portal</td>
<td>The API delivery component that allows API Providers to engage with,
onboard, educate and manage Application Developers whether inside or
outside the organisation. These management activities will generally
include registration, documentation, analytics etc.</td>
</tr>
<tr class="odd">
<td>API Gateway</td>
<td>The API delivery component that allows API Providers to offer APIs
to the outside world. This component (physical or virtual) hosts the
APIs ready for Consumers to access. It provides an API Provider with the
ability to control who has access to their APIs by enforcing policies
for access control. Some API gateways also offer additional
capabilities.</td>
</tr>
<tr class="even">
<td>API Manager</td>
<td>The API delivery component that allows API Providers to control an
API’s visibility and behaviour. It is usually exposed as a UI/console to
internal staff only, as it is seen as an administration component. It
offers a variety of capabilities, including API registration and
catalogue administration.</td>
</tr>
<tr class="odd">
<td>API Provider</td>
<td>Organisation who provides the API to expose a resource (information
or functionality) for Consumers.</td>
</tr>
<tr class="even">
<td>Application</td>
<td>The software behind the API which provides the business logic for
the resource.</td>
</tr>
<tr class="odd">
<td>Application Developer</td>
<td>Software developer or organisation who builds Consuming Applications
that use the API. An application developer can be internal to your
agency, developers that work with trusted partners, developers from
other agencies or developers from the private sector.</td>
</tr>
<tr class="even">
<td>Interface Specification</td>
<td>Provides technical information to the API Developer community about
the API. It includes information about how the API works, any access
control features and any error conditions.</td>
</tr>
<tr class="odd">
<td>Product Manager</td>
<td>The product manager is usually a technical role. They understand an
agency's API landscape and are owners of API management platforms.</td>
</tr>
<tr class="even">
<td>Product Owners</td>
<td>The product ownership function usually resides in a business area
rather than technology. The role of the product owner is to understand
the product that the agency is trying to deliver and be able to make
decisions on the representation of the product in an API.</td>
</tr>
<tr class="odd">
<td>Publish</td>
<td>The act of releasing the interface specification and associated API
to a location accessible by Application Developers</td>
</tr>
<tr class="even">
<td>Resource</td>
<td>The information or functionality exposed by the API.</td>
</tr>
<tr class="odd">
<td>State</td>
<td>State defines the point in time record of an in-flight transaction.
Some systems maintain <em>user state</em> for a period of time to enable
a transaction to be continued from the point of last recorded state.
APIs are usually, but not always, considered stateless.</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234995" class="anchor"></span>Table 6: Glossary of
Terms</p>
<h1 id="glossary-of-acronyms">Glossary of acronyms</h1>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>Term</th>
<th>Definition</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>AD</td>
<td>Active Directory</td>
</tr>
<tr class="even">
<td>API</td>
<td>Application Programming Interface</td>
</tr>
<tr class="odd">
<td>ASCII</td>
<td>American Standard Code for Information Interchange</td>
</tr>
<tr class="even">
<td>CA</td>
<td>Certificate Authority</td>
</tr>
<tr class="odd">
<td>CDN</td>
<td>Content Delivery Network</td>
</tr>
<tr class="even">
<td>DHE</td>
<td>Diffie-Hellman Ephemeral</td>
</tr>
<tr class="odd">
<td>DMZ</td>
<td>Demilitarized Zone</td>
</tr>
<tr class="even">
<td>DoS</td>
<td>Denial of Service</td>
</tr>
<tr class="odd">
<td>ECDHE</td>
<td>Elliptic Curve DHE</td>
</tr>
<tr class="even">
<td>HATEOAS</td>
<td>Hypermedia As The Engine Of Application State</td>
</tr>
<tr class="odd">
<td>HPP</td>
<td>HTTP Parameter Pollution</td>
</tr>
<tr class="even">
<td>HTTP</td>
<td>HyperText Transfer Protocol</td>
</tr>
<tr class="odd">
<td>IETF</td>
<td>Internet Engineering Task Force</td>
</tr>
<tr class="even">
<td>JSON</td>
<td>JavaScript Object Notation</td>
</tr>
<tr class="odd">
<td>JWA</td>
<td>JSON Web Algorithms</td>
</tr>
<tr class="even">
<td>JWE</td>
<td>JSON Web Encryption</td>
</tr>
<tr class="odd">
<td>JWK</td>
<td>JSON Web Key</td>
</tr>
<tr class="even">
<td>JWS</td>
<td>JSON Web Signature</td>
</tr>
<tr class="odd">
<td>JWT</td>
<td>JSON Web Token</td>
</tr>
<tr class="even">
<td>LDAP</td>
<td>Lightweight Directory Access Protocol</td>
</tr>
<tr class="odd">
<td>MAC</td>
<td>Message Authentication Code</td>
</tr>
<tr class="even">
<td>OWASP</td>
<td>Open Web Application Security Project</td>
</tr>
<tr class="odd">
<td>PBD</td>
<td>Primary Business Data</td>
</tr>
<tr class="even">
<td>RAML</td>
<td>Rest API Modelling Language</td>
</tr>
<tr class="odd">
<td>REST</td>
<td>Representative State Transfer</td>
</tr>
<tr class="even">
<td>RFC</td>
<td>Request for Comments (IETF)</td>
</tr>
<tr class="odd">
<td>RO</td>
<td>Resource Owner</td>
</tr>
<tr class="even">
<td>RS</td>
<td>Resource Server</td>
</tr>
<tr class="odd">
<td>SAML</td>
<td>Security Assertion Markup Language</td>
</tr>
<tr class="even">
<td>SCIM</td>
<td>System for Cross-domain Identity Management</td>
</tr>
<tr class="odd">
<td>SEO</td>
<td>Search Engine Optimization</td>
</tr>
<tr class="even">
<td>SLA</td>
<td>Service Level Agreement</td>
</tr>
<tr class="odd">
<td>SOAP</td>
<td>Simple Object Access Protocol</td>
</tr>
<tr class="even">
<td>SPML</td>
<td>Service Provisioning Markup Language</td>
</tr>
<tr class="odd">
<td>SQL</td>
<td>Structured Query Language</td>
</tr>
<tr class="even">
<td>SSO</td>
<td>Single Sign On</td>
</tr>
<tr class="odd">
<td>STS</td>
<td>Security Token Service</td>
</tr>
<tr class="even">
<td>TBC</td>
<td>To Be Completed</td>
</tr>
<tr class="odd">
<td>TBD</td>
<td>To Be Done</td>
</tr>
<tr class="even">
<td>TLS</td>
<td>Transport Layer Security (superseded SSL)</td>
</tr>
<tr class="odd">
<td>URL</td>
<td>Uniform Resource Locator</td>
</tr>
<tr class="even">
<td>URI</td>
<td>Uniform Resource Identifier</td>
</tr>
<tr class="odd">
<td>WSDL</td>
<td>Web Service Definition Language</td>
</tr>
<tr class="even">
<td>XSD</td>
<td>XML Schema Definition</td>
</tr>
<tr class="odd">
<td>WADL</td>
<td>Web API Description Language</td>
</tr>
<tr class="even">
<td>XACML</td>
<td>eXtensible Access Control Markup Language</td>
</tr>
<tr class="odd">
<td>XML</td>
<td>eXtensible Markup Language</td>
</tr>
<tr class="even">
<td>YAML</td>
<td>YAML Ain't Markup Language</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234996" class="anchor"></span>Table 7: Glossary of
acronyms</p>
<h1 id="further-reading"><br />
Further Reading</h1>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td>OWASP REST Security</td>
<td><a
href="https://www.owasp.org/index.php/REST_Security_Cheat_Sheet"><u>https://www.owasp.org/index.php/REST_Security_Cheat_Sheet</u></a></td>
</tr>
<tr class="even">
<td>OWASP API Security Project</td>
<td><u><a
href="https://www.owasp.org/index.php/OWASP_API_Security_Project">https://www.owasp.org/index.php/OWASP_API_Security_Project</a></u></td>
</tr>
<tr class="odd">
<td>OWASP Top Ten Project</td>
<td><u><a
href="https://owasp.org/www-project-top-ten/">https://owasp.org/www-project-top-ten/</a></u></td>
</tr>
<tr class="even">
<td>OWASP Secure Coding Principles</td>
<td><u><a
href="https://www.owasp.org/index.php/Secure_Coding_Principles">https://www.owasp.org/index.php/Secure_Coding_Principles</a></u></td>
</tr>
<tr class="odd">
<td>NZ Protective Security</td>
<td><a
href="https://www.protectivesecurity.govt.nz/"><u>https://www.protectivesecurity.govt.nz/</u></a></td>
</tr>
<tr class="even">
<td>Using HTTP Methods for RESTful Services</td>
<td><a
href="https://www.restapitutorial.com/lessons/httpmethods.html">https://www.restapitutorial.com/lessons/httpmethods.html</a></td>
</tr>
<tr class="odd">
<td>Reserved JavaScript Keywords</td>
<td><a
href="https://www.w3schools.com/js/js_reserved.asp">https://www.w3schools.com/js/js_reserved.asp</a></td>
</tr>
<tr class="even">
<td>REST API Resource Modelling</td>
<td><a
href="https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling"><u>https://www.thoughtworks.com/insights/blog/rest-api-design-resource-modeling</u></a></td>
</tr>
<tr class="odd">
<td>Government ICT Strategy</td>
<td><a
href="https://www.ict.govt.nz/strategy-and-action-plan/strategy/"><u>https://www.ict.govt.nz/strategy-and-action-plan/strategy/</u></a></td>
</tr>
<tr class="even">
<td>OpenAPI Specification</td>
<td><a
href="https://github.com/OAI/OpenAPI-Specification"><u>https://github.com/OAI/OpenAPI-Specification</u></a></td>
</tr>
<tr class="odd">
<td>HTTP 1.1 Standards RFCs</td>
<td><p><a
href="https://tools.ietf.org/html/rfc7230"><u>https://tools.ietf.org/html/rfc7230</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7231"><u>https://tools.ietf.org/html/rfc7231</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7232"><u>https://tools.ietf.org/html/rfc7232</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7233"><u>https://tools.ietf.org/html/rfc7233</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7234"><u>https://tools.ietf.org/html/rfc7234</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7235"><u>https://tools.ietf.org/html/rfc7235</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7236"><u>https://tools.ietf.org/html/rfc7236</u></a></p>
<p><a
href="https://tools.ietf.org/html/rfc7237"><u>https://tools.ietf.org/html/rfc7237</u></a></p></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234997" class="anchor"></span>Table 11: Further
reading</p>
<h1 id="appendix-a---standards-for-securing-restful-apis">Appendix A -
Standards for Securing RESTful APIs </h1>
<h2 id="standards-for-securing-restful-apis">Standards for Securing
RESTful APIs</h2>
<blockquote>
<p>The table below captures (current) security standards that should be
part of any API Security Strategy, ordered by type. The provisioning
standards are included to complete the Identity and Access Standards
table. This enables it to be used by architects to select the most
appropriate option.</p>
</blockquote>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 73%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Provisioning</td>
<td>Provides the framework for managing the provisioning of user and
their access to APIs e.g. the process for internal or external
developers gaining access to API development and publishing
services</td>
</tr>
<tr class="even">
<td>SPML</td>
<td><p>Service Provisioning Markup Language is an XML based framework
for facilitating the exchange of provisioning information (creates,
updates and deletes) on user objects (e.g. an LDAP Directory). This is
normally implemented to provide Just in Time (Real Time)
provisioning.</p>
<p>Although now regarded by most as a legacy standard, it is still
supported by most vendors and used by niche service vendors.</p></td>
</tr>
<tr class="odd">
<td>SCIM</td>
<td><p>System for Cross-domain Identity Management. This is a RESTful
API-based framework for Just in Time provisioning and, like SPML, moves
away from batch- and delta-based provisioning processes. It uses a
RESTful API to manage the provisioning of users.</p>
<p>As SCIM is a REST API framework it should be secured using
OAuth.</p></td>
</tr>
<tr class="even">
<td>Federation / Authentication</td>
<td>Provides authentication and Single Sign On services to customers and
secure transportation of authentication and authorisation
information.</td>
</tr>
<tr class="odd">
<td>SAML</td>
<td><p>Security Assertion Markup Language (SAML) is an XML-based,
open-standard data format for exchanging authentication and
authorisation data between parties; in particular, between an identity
provider and a service provider.</p>
<p>SAML is seen as complex but is regarded as a high-level security
framework.</p>
<p>As it is based on XML, SAML can have high payload overheads and thus
can result in performance issues in the mobile application space.</p>
<p>It is still widely used but its uptake is declining. It is included
in this standard to support existing New Zealand SAML instances (e.g.
education, RealMe).</p></td>
</tr>
<tr class="even">
<td>OpenID Connect</td>
<td><p>OpenID Connect is an interoperability authentication protocol
based on the OAuth 2.0 framework.</p>
<p>This is a relatively recent federation protocol that provides
lightweight federation services. It, like SAML, provides SSO services
and allows the secure exchange of user authentication data, but it is
not as feature rich as SAML.</p>
<p>As it is based on REST/JSON, it is perceived as the Federation
service of choice for mobile services.</p></td>
</tr>
<tr class="odd">
<td>Claims</td>
<td>Claims are the contents of tokens and are pieces of information
asserted about a subject. For example, an ID Token can contain a claim
called mobile which asserts the subjects mobile phone number.</td>
</tr>
<tr class="even">
<td>CIBA</td>
<td>Client Initiated Backchannel Authentication and it is a decoupled
grant flow that allows the end user to use their mobile device to
authenticate and approve transactions.</td>
</tr>
<tr class="odd">
<td>Delegated Authorisation</td>
<td>Provides a framework for delegating the specified access rights to a
3<sup>rd</sup> party.</td>
</tr>
<tr class="even">
<td>OAuth 1.0a</td>
<td>OAuth 1.0a is derived from the original OAuth 1.0 specification (RFC
5849) which provides a method for client applications to access
resources on behalf of a resource owner. It is an authentication
framework around the exchange of signed tokens. It has now been made
obsolete by OAuth 2.0.</td>
</tr>
<tr class="odd">
<td>OAuth 2.0</td>
<td><p>OAuth 2.0 is an open standard for a delegated authorisation
framework. It is not backward compatible with OAuth 1.0, but is modelled
on the framework with the objective of providing greater flexibility and
defines specific credential (grant) flows.</p>
<p>It is also based on token exchange, with the primary difference being
that the tokens are secured by mandating TLS on all communication
connections (RFC 6749), where the OAuth 1 tokens are digitally
signed.</p></td>
</tr>
<tr class="even">
<td>OAuth 2.1</td>
<td><a
href="https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00"><u>https://tools.ietf.org/html/draft-ietf-oauth-v2-1-00</u></a>.
This is an update to OAuth 2.0</td>
</tr>
<tr class="odd">
<td>PKCE</td>
<td>Proof of Key Code Exchange provides enhanced security for the
Authorisation code flow.</td>
</tr>
<tr class="even">
<td>Authorisation Standards</td>
<td>Provides a framework for controlling access to resources.</td>
</tr>
<tr class="odd">
<td>XACML</td>
<td><p>The eXtensible Access Control Markup Language standard is XML
based and defines a fine-grained attribute-based access control policy
language.</p>
<p>It provides an architectural model and policy terminology that can be
used to separate out the functions of any authorisation framework.</p>
<p>As it is based on XML it is sometimes perceived as a legacy standard,
but, from a RESTful API perspective, it provides a fine-grained
attribute-based authorisation framework. (RFC 7061)</p></td>
</tr>
<tr class="even">
<td>UMA</td>
<td><p>User-Managed Access is an OAuth-based access management protocol
standard.</p>
<p>It builds on OAuth 2.0 to provide additional delegated authorisation
capabilities.</p>
<p>Its key focus, for RESTful APIs, is to enable an individual (Resource
Owner) to manage and define a set of access control policies that can be
managed by an Authorisation Server, which controls access to a set of
APIs.</p></td>
</tr>
<tr class="odd">
<td>ALFA</td>
<td><p>Abbreviated Language for Authorisation defines fine-grained
authorisation rules in a JSON-like policy language.</p>
<p>This language helps remove one of the greatest barriers for
implementing XACML, which is complexity in writing of the access control
policies.</p></td>
</tr>
<tr class="even">
<td>Two (Multi)-factor Authentication</td>
<td>This is a method of confirming a user’s claimed identity
(authentication) by using two or more pieces of evidence, relating to
something they know, something they have and something they are.</td>
</tr>
<tr class="odd">
<td>U2F / FIDO</td>
<td>Universal 2<sup>nd</sup> Factor is an open authentication standard
that can be incorporated into an API security framework</td>
</tr>
<tr class="even">
<td>TOTP / HOTP</td>
<td><p>Time-based and HMAC-based One-Time Password. These can be used in
any of the authentication processes that are part of the process of
gaining access to APIs. The requirements for these would be based on
business requirements and risk analysis of the information or service
being exposed by the API.</p>
<p>These could be used to add a second authentication factor to any
existing or proposed authorisation mechanisms.</p></td>
</tr>
<tr class="odd">
<td>JSON Security Standards</td>
<td>This is a set of standards that provide security around the exchange
of tokens, based on JSON.</td>
</tr>
<tr class="even">
<td>JWT</td>
<td><p>A JSON Web Token is designed to be compact and provides trusted
information that is used in the authentication process.</p>
<p>Used in API security to pass identity information, specifically by
OpenID Connect.</p></td>
</tr>
<tr class="odd">
<td>JWE</td>
<td>JSON Web Encryption standard provides integrity validation and can
be used with or without digital signatures.</td>
</tr>
<tr class="even">
<td>JWS</td>
<td>JSON Web Signature is a standard for signing JSON, thus providing a
level of authority (where it has come from) and integrity, by proving
the JWT hasn’t been changed in transit.</td>
</tr>
<tr class="odd">
<td>JWA</td>
<td>JSON Web Algorithm defines the algorithms used for encrypting the
JWT.</td>
</tr>
<tr class="even">
<td>JWK</td>
<td>JSON Web Keys represent the cryptographic key used for encrypting
JWT. The algorithms for these are defined in JWA.</td>
</tr>
<tr class="odd">
<td>Industry Standards</td>
<td></td>
</tr>
<tr class="even">
<td>FAPI</td>
<td>Financial Grade APIs is an OpenID workgroup that now defines a set
of specifications that that are enforces in specific legislation e.g.
Open Banking (NZ) and Customer Data Rights (Australia)</td>
</tr>
<tr class="odd">
<td>FHIR</td>
<td>Fast Healthcare Interoperability Resources is a standard describing
data formats and elements and an application programming interface for
exchanging electronic health records.</td>
</tr>
<tr class="even">
<td>PNZ</td>
<td>Payments New Zealand is a government body that is driving the Open
Banking initiative in New Zealand</td>
</tr>
<tr class="odd">
<td>NZ Trust Framework</td>
<td>This is the framework that is driving NZ future Digital Identity
direction.
https://www.digital.govt.nz/digital-government/programmes-and-projects/digital-identity-programme/digital-identity-trust-framework/</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234998" class="anchor"></span>Table 12: API Security
Standards</p>
<h1 id="appendix-b---authentication">Appendix B - Authentication</h1>
<h2 id="anonymous-authentication">Anonymous Authentication</h2>
<p><strong><span class="smallcaps">Not Recommended</span></strong></p>
<p>This is where the customer and the application they are using can
gain access to backend API services without needing to authenticate in
any way.</p>
<p><img src="media/image30.png"
style="width:5.28463in;height:1.32769in" /></p>
<p><span id="_Toc74234886" class="anchor"></span>Figure 34: Anonymous
Authentication Model</p>
<p>This approach can be used when the risk associated with the API is
negligible e.g. an API offering publicly available information. It can
be used for internal APIs if the agency’s security policy allows.</p>
<p>The downside of this model is that it makes it difficult to gather
effective analytics, and therefore to understand the implications of
proposed changes to, and deprecation of, an API.</p>
<p>Although it is not recommended to use this pattern it sometimes has
to be included to support the scenario where a web application is making
calls, on the home or login page, to a back-end application server which
stores the pages and the related JavaScripts. In this case it is the API
Gateway that provides the security, along with the due diligence
required to ensure these pages and associated JavaScripts do not contain
information that should be secured.</p>
<p>The Anonymous authentication model should be protected against
typical API vulnerabilities and threats, as listed on the OWASP (Open
Web Application Security Project) web site. Typically, these relate
to:</p>
<ol type="1">
<li><p>Throttling to prevent Denial of Service attacks</p></li>
<li><p>Message analysis to block HTTP attacks parameter attacks such as
cross-site scripting, SQL injection, command injection and cross site
request forgery</p></li>
</ol>
<p>Note: If this approach is used, it might be appropriate to restrict
access to the API based on other information (e.g. based on IP address).
This capability can be applied using an API Gateway, or existing
capabilities (e.g. firewalls, load balancers etc) may be able to provide
this level of protection</p>
<h2
id="username-and-password-authentication-direct-authentication">Username
and Password Authentication (Direct Authentication) </h2>
<p><strong><span class="smallcaps">Not Recommended</span></strong></p>
<p>In the Direct Authentication model, the user is authenticated via an
identity store using username and password (or hash) credentials over
secure communications.</p>
<p>Username and Password Authentication is suitable for development
purposes, during training or the initial stages of development because
it reduces the barrier to accessing the API. It could also be used for
internal APIs, if the agency’s security policy allows, and may be
suitable for customers if the identity risk<a href="#fn8"
class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a>
associated with the API is low.</p>
<p>Internal users would likely use an internal LDAP directory (e.g.
Active Directory) whilst external users (e.g. customers) would require a
separate identity store. The API Gateway could provide the
authentication services and, for external facing APIs, also threat
protection services.</p>
<p>API security is provided by the Application (Web) Server acting as a
trusted subsystem with TLS links to the backend API Server. The
Application/Web Server invokes the backend and provides the required
user ID information, which can be in the form of a session token.</p>
<p><img src="media/image31.png"
style="width:5.90139in;height:3.70347in" /></p>
<p><span id="_Toc74234887" class="anchor"></span>Figure 35: HTTP Basic /
Digest Authentication Model</p>
<p>This model can be easy to implement but has many limitations:</p>
<ol type="1">
<li><p>An identity store (e.g. LDAP) is required along with a full
registration process for all user types (e.g. applications and
application developers)</p></li>
<li><p>Cannot leverage a federated authentication model, so no single
sign on (SSO), requiring re-presentation of username and password at
every step</p></li>
<li><p>Passwords would be in clear text. If direct authentication is
used, TLS would be required to secure all communications</p></li>
<li><p>Open to brute force attacks</p></li>
<li><p>Passwords have low entropy, have to be reset and managed, and are
difficult to revoke at a granular level</p></li>
</ol>
<p>This model can be used for testing and development purposes but is
<strong>Not Recommended</strong> for production APIs; API Keys are
preferred. Refer to the NZ Evidence of Identity Standard for guidance on
customer authentication. If considering using this model for internal
users, preference would be a Single Sign-On solution using Kerberos.</p>
<h2 id="api-keys-authentication">API Keys Authentication</h2>
<p><strong><span class="smallcaps">Recommended</span></strong></p>
<p>API Keys are a digital authentication mechanism, with the API key
taking the form of a long string of generated characters. API keys are
usually unique and can be assigned to an application, developer, or
user. The usual practice is for an application developer to obtain a key
for their application from the API provider and utilise the key within
their application. To obtain an API key, the developer must undergo a
registration process with the API Provider. The steps involved in the
registration process are dependent on the level of risk associated with
the API.</p>
<p><img src="media/image32.png"
style="width:5.90139in;height:2.61528in" /></p>
<p><span id="_Toc74234888" class="anchor"></span>Figure 36: API Key
Authentication</p>
<p>At run time, the consuming application automatically passes the API
Key to the API every time it requests an API resource. The API Gateway
validates the API Key against the API Key Store (which can be part of
the API Gateway functionality or provided by another secure device)
before allowing the consuming application access to the requested API
(or set of APIs) and backend resources.</p>
<p>This model is similar to the Username and Password model, but it is
the API Gateway which can be responsible for creating, managing the API
key and API secret and storing a copy in the API key store for
validation, rather than redirecting to an identity store for policy
validation and approval.</p>
<p>Username and password authorisation models can have high
administration and response time overheads (relating to cryptographic
functions). API keys are not linked to users and require no
cryptographic functions. Like usernames and passwords, they come in
pairs and are defined below:</p>
<ul>
<li><p>API Key - public unique identifier – a 40+ random character
string to authenticate the consuming application to the API</p></li>
<li><p>API Secret – private unique identifier- only known by the API
Gateway and used to validate the API key. The API secret in this model
is not passed over the network.</p></li>
</ul>
<p>API Keys should be used wherever system to system authentication is
needed (especially with a production level API). They are suitable for
simple public APIs which do not need more complex authentication models.
API Keys should be used in preference to username and passwords
because:</p>
<ul>
<li><p>More secure - greater entropy than passwords – random long string
of characters</p></li>
<li><p>Speed – API keys do not involve any hashing process, i.e. the
hashing process required for passwords</p></li>
</ul>
<p>However, the risk is that anyone with a copy of the API key can use
it as though they were the legitimate consuming application. Hence all
communications should be over TLS, to protect the key in transit. The
onus is on the application developer to properly protect their copy of
the API key. If the API key is embedded into the consuming application,
it can be decompiled and extracted. If stored in plain text files they
can be stolen and re-used for malicious purposes.</p>
<p>Note: API Keys are recommended as they provide a level of security to
public APIs that can help protect sites from screen scraping or provide
the required information to throttle, or possibly bill, access to data.
Organisations need to carry out a risk analysis of the possible threats
against the classification of the data that could be obtained and from
this decide if API Keys are required.</p>
<h2 id="certificates-mutual-authentication">Certificates (Mutual)
Authentication</h2>
<p>Use this model when the API requires stronger authentication<a
href="#fn9" class="footnote-ref" id="fnref9"
role="doc-noteref"><sup>9</sup></a> than offered solely by API Keys, and
the overhead of certificate management is warranted.</p>
<p>In Certificate (Mutual) Authentication, internal and external parties
are authenticated with each other. Both the consuming application and
the API provider hold a digital certificate. The digital certificate can
be trusted because it was issued by a mutually trusted Certificate
Authority (CA). When the consuming application makes a request to the
API, the server hosting the API presents its certificate to the
consuming app. The app verifies the server’s certificate then sends its
own certificate to the server. The server verifies the client
certificate and mutual trust is achieved, allowing the consuming
application to use the API.</p>
<p><img src="media/image33.png"
style="width:5.90139in;height:2.47502in" /></p>
<p><span id="_Toc74234889" class="anchor"></span>Figure 37: Certificate
Authentication</p>
<p>This is <strong>Not Recommended</strong> for customer authentication
as there would be a high overhead in terms of certificate
management.</p>
<p>This is <strong>Recommended</strong> for consuming application to
server (gateway) or API to back-end communications (if needed).</p>
<p>Refer to the NZ Information Security Manual for guidance.</p>
<h2 id="developer-authentication">Developer Authentication</h2>
<blockquote>
<p>Developer authentication will normally take place at the API Portal
when gaining access to APIs.</p>
<p>The API Portal will offer an authentication solution for developers
to provide a username and password (possible two factor) login process
(See Figure 33) and a user store. Further details for this are not
provided in this document, but a vendor API Portal will normally provide
their own authentication solution and user store, or it can integrate
with an existing identity and access management system.</p>
</blockquote>
<p><img src="media/image34.png" style="width:5.17351in;height:3.52673in"
alt="Graphical user interface, text, application Description automatically generated" /></p>
<p><span id="_Toc74234890" class="anchor"></span>Figure 38: API Portal
Login Page</p>
<blockquote>
<p>Once the developer has logged into the API Portal they can browse and
discover the APIs available. API Portals normally require the consuming
application developer to:</p>
</blockquote>
<ol type="1">
<li><p>Provide contact details e.g. email address</p></li>
<li><p>Register the application they are developing</p></li>
</ol>
<blockquote>
<p>The API Portal should provide registration services for the client
application to use:</p>
</blockquote>
<ol type="1">
<li><p>API keys for basic authentication services and API
monitoring</p></li>
<li><p>OAuth services and the management of Client ID and a Client
Secrets (for applications)</p></li>
<li><p>Additional production authentication and authorisation service
e.g. basic, certificate etc.</p></li>
</ol>
<h2 id="multi-factor-authentication-mfa">Multi Factor Authentication
(MFA)</h2>
<blockquote>
<p>An application could use multi-factor authentication (MFA) to enhance
other authentication techniques to mitigate identity risks. For example,
by requesting a fingerprint from the customer in addition to their
username and password (or API key).</p>
<p>Often smartphone capabilities can be leveraged to provide this
additional factor, but other options are available, like smart cards or
hardware tokens.</p>
</blockquote>
<h1 id="appendix-c---oauth-2.0">Appendix C - OAuth 2.0</h1>
<p>OAuth 2.0 is a Token-based authorisation framework and is defined and
implemented using Grant Flow type patterns. These define the different
types of interaction a client application can perform to gain an “access
token” and thus access to the protected resource.</p>
<p>There are four grant type flows supported by the OAuth 2.0:</p>
<ol type="1">
<li><p>Authorisation Code</p></li>
<li><p>Implicit</p></li>
<li><p>Resource Owner Password Credentials</p></li>
<li><p>Client Credentials</p></li>
</ol>
<h2 id="grant-types">Grant Types </h2>
<blockquote>
<p>The following table explains which grant flow type to use for which
situation:</p>
</blockquote>
<table>
<colgroup>
<col style="width: 58%" />
<col style="width: 41%" />
</colgroup>
<thead>
<tr class="header">
<th>Description</th>
<th>Recommendations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td colspan="2"><strong>Authorisation Code</strong></td>
</tr>
<tr class="even">
<td><p>Use for Internal Users or where the Customer is the Resource
Owner, your agency controls the Resource Server, but the Authorisation
server is not owned by the agency or is elsewhere within the
organisation.</p>
<ul>
<li><p>The Authorisation Server provides the Authorisation Code (grant)
to the client application once the Resource Owner has approved the
request</p></li>
<li><p>The client application then uses this to request the access
token</p></li>
<li><p>The Authorisation Server validates the client application using
the Client ID and Client Secret. The client application has to store
these credentials securely</p></li>
<li><p>The client application authenticates to the Authorisation Server
via its TLS certificate and call-back URL</p></li>
</ul>
<p>Useful if the API requires a customer of a client application to
authorise access to a protected resource provided by the API.</p></td>
<td><p><strong>Recommended</strong></p>
<p>The most secure OAuth flow.</p>
<p>Use for public facing APIs for Customer Authorisation patterns.</p>
<p>Use for Internal Use Only pattern.</p>
<p>Use the state attribute to link request and response.</p>
<p>It is now recommended to include PKCE in this flow.</p></td>
</tr>
<tr class="odd">
<td colspan="2"><strong>Implicit</strong></td>
</tr>
<tr class="even">
<td><p>Used when the client application resides on a device (e.g.
smartphone) and cannot secure the credentials.</p>
<p>Only the “Access token” is transmitted from the Authorisation Server
to the client.</p></td>
<td><p><strong>Not Recommended</strong></p>
<p>The least secure grant type.</p>
<p>If used it should ONLY be for information that is public and ONLY for
GETs.</p></td>
</tr>
<tr class="odd">
<td colspan="2"><strong>Resource Owner Password
Credentials</strong></td>
</tr>
<tr class="even">
<td>The Resource Owner’s username and password are used once as the
Authorisation grant to obtain an Access Token. The credentials are then
discarded.</td>
<td><p><strong>Not Recommended</strong></p>
<p>Use for Customer Authorisation pattern if Authorisation Code grant
flow can’t be used.</p>
<p>Use for Internal Use Only pattern to secure Internal APIs that use
Active Directory Groups / Kerberos for authorisation and authentication
if Authorisation Code grant flow is not available.</p></td>
</tr>
<tr class="odd">
<td colspan="2"><strong>Client Credentials</strong></td>
</tr>
<tr class="even">
<td>The client application is able to obtain access to the protected
resource on its own behalf.</td>
<td><p><strong>Recommended</strong></p>
<p>Use:</p>
<ul>
<li><p>For the Authorise Consuming Application pattern from device to
API</p></li>
<li><p>Also use for Server to Server (B2B), using signed tokens</p></li>
<li><p>when the Customer using the client, application is also the
Resource Owner</p></li>
</ul></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74234999" class="anchor"></span>Table 13: OAuth 2.0
Grant Types</p>
<p>This table compiles the different grant types and provides
recommendations for agencies implementing an API Security Framework.
Recommendations are based on maximising the level of security for the
APIs being exposed.</p>
<p>OAuth 2.0 introduced different grant types to provide organisations
with the flexibility to support a variety of client application models.
These specific models are not device driven i.e. there is no specific
device (e.g. mobile) mapping to grant type; it is the level of risk an
agency is prepared to support that needs to be defined to clarify which
grant type should be selected.</p>
<p>For the application developer, the difference is in the
infrastructure they need to provide e.g. the “Authorisation Code” model
requires a managed server on which the client application runs.</p>
<p>The “Authorisation Code” is the most frequently used model and as it
is regarded as the most secure model it is covered in more depth later
in this document. The Implicit grant is the least secure and to quote
from the OAuth RFC:</p>
<blockquote>
<p><em>“Implicit grants improve the responsiveness and efficiency of
some clients (such as a client implemented as an in-browser
application), since it reduces the number of round trips required to
obtain an access token. However, this convenience should be weighed
against the security implications of using implicit grants”</em></p>
</blockquote>
<p>These OAuth 2.0 Grant flow types replace the two-legged and
three-legged patterns used in OAuth 1.0.</p>
<p>There is now an RFC that has been defined that provides a Device
Authorization Grant flow (grant_type) that has been developed to address
“browser less” devices e.g. smart TVs, printers etc. and uses another
device to connect to the authorisation server to approve the request via
a polling process.</p>
<h1
id="appendix-d---oauth-2.0-and-openid-connect-tokens-credentials">Appendix
D - OAuth 2.0 and OpenID Connect Tokens &amp; Credentials</h1>
<p>Access tokens are becoming a standard form of access control without
the need for passing credentials. Anyone with an access token (bearer
token) is permitted access to the resource being controlled, which makes
tokens a target for stealing or copying. Hence it is important to keep
the lifetime of tokens as short as realistically possible, depending on
the type of resource being exposed and business risk appetite.</p>
<p>The OAuth framework (RFC 6749 and 6750) relies heavily on TLS for the
security of the bearer token. The following RFCs offer additional
integrity and confidentiality capability that can be applied to the
bearer token (access token):</p>
<ul>
<li><p>JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication
and Authorization Grants (RFC 7523)</p></li>
<li><p>Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs) (RFC
7800)</p></li>
</ul>
<p>There are two types of tokens, Opaque and JWTs. Both the access and
refresh token can be presented in either form.</p>
<p>The Opaque Tokens are produced by, and stored in, the Authentication
Server. Each one has a specific task in the OAuth 2.0 framework.</p>
<p>The JWT tokens are produced and signed by the Authorisation Server
but are not stored there. They are stored by the Client Application and
when used are verified by the signature.</p>
<p>The table below provides a list of the main tokens and credentials
that are used to provide authentication and authorisation services in
the OAuth 2.0 framework.</p>
<table>
<colgroup>
<col style="width: 53%" />
<col style="width: 46%" />
</colgroup>
<thead>
<tr class="header">
<th>Description</th>
<th>Recommendation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Access Tokens (Opaque)</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td><p>Also called bearer tokens. No additional identity checks are
carried out once this has been issued.</p>
<p>Used by the client application to access protected resources on the
provider, and it can be signed.</p>
<p>It is a random character string that also contains “scope”
information to allow additional access policies to be applied e.g.
duration of access.</p>
<p>It is granted by the Resource Owner via the Authorisation Grant Token
Flow and enforced by Authorisation and Resource Servers.</p></td>
<td><ul>
<li><p>It is <strong>Required</strong> that the token be protected both
in transit (TLS) and in storage (encryption)</p></li>
<li><p>The “Authorisation Request Header Field” format is
<strong>Required</strong> to only be used to transmit tokens</p></li>
<li><p>It is <strong>Recommended</strong> that the lifetime of this
token be set to 60 mins</p></li>
<li><p>It is <strong>Recommended</strong> that scopes be used for
coarse- and fine-grained access</p></li>
<li><p>Form-Encoded Body Parameter is <strong>Not Recommended</strong>
for transmission</p></li>
<li><p>URI Query Parameter is <strong>Not Recommended</strong> for
transmission</p></li>
</ul></td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Refresh Token (Opaque)</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td>Used to obtain new Access tokens when the old one expires or is
invalid.</td>
<td><ul>
<li><p>It is <strong>Required</strong> that the token be protected both
in transit (TLS) and in storage (encryption)</p></li>
<li><p>It is <strong>Recommended</strong> that the lifetime of this
token be set to 24 hours</p></li>
</ul></td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Opaque Tokens vs JWTs</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td><p>Access and Refresh Tokens can be delivered as an Opaque string or
as a JWT that is signed, and if required can be encrypted. Possible pros
and cons of the JWT are:</p>
<ol type="1">
<li><p>JWTs are self-contained as all the information required is within
the token</p></li>
<li><p>JWTs provide signing services to allow the verification of the
token</p></li>
<li><p>JWT are harder to revoke</p></li>
</ol></td>
<td><ul>
<li><p>It is <strong>Recommended</strong> that organisations investigate
both options and understand the differences between the two and defined
how one over the other can provide additional security controls or
limits complexity.</p></li>
<li><p>It can be noted that there is a move towards the JWT token as it
can be used in the microservice space as the claims information are
contained inside.</p></li>
</ul></td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Authorisation Code</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td><p>The Authentication Server sends the Authorisation Code to the
Client after being granted consent by the Resource Owner.</p>
<p>Used to authenticate the client.</p></td>
<td>It is <strong>Recommended</strong> that the lifetime of this token
be set to 24 hours</td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>API Key</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td>A 40+ random character string used in some scenarios to authenticate
the client application to the API.</td>
<td><strong>Required</strong> when implementing an authorisation
solution that uses API Keys. This is normally presented as an option in
the developer API Portal.</td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Client ID</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td><p>When registering an OAuth Client application with the API Portal,
a Client ID is issued.</p>
<p>Used when interacting with the Resource Server.</p></td>
<td><strong>Required</strong> when implementing an OAuth 2.0 model that
supports “Authorisation Code” flow</td>
</tr>
<tr class="odd">
<td colspan="2"><blockquote>
<p><strong>Client Secret</strong></p>
</blockquote></td>
</tr>
<tr class="even">
<td>Also provided when the OAuth Client application is registered. This
is used with the Client ID when exchanging an authorisation code for an
access token</td>
<td><strong>Required</strong> when implementing an OAuth 2.0 model that
supports “Authorisation Code” flow</td>
</tr>
<tr class="odd">
<td colspan="2"><strong>ID Token</strong></td>
</tr>
<tr class="even">
<td><p>ID Tokens are JWTs that can be used to:</p>
<ol type="1">
<li><p>Authenticate a user</p></li>
<li><p>Collect information about a user and send it in a verifiable
format that can be trusted by the relying party</p></li>
<li><p>Provide information in the token that can be used to customise
the Client application or to provide claims for an access
policy</p></li>
<li><p>Provide a set of hashed claims that can be used to verify that
the ID Token and related Access / Refresh Tokens can be from the Service
Provider.</p></li>
</ol></td>
<td><p>It is <strong>Recommended</strong> that there are incorporated
into any OAuth 2.0 / OpenID Connect environments as they provide
additional security controls that allow a higher level of communication
trust between the Relying Party the Identity Provider and the service
being protected.</p>
<p>Using ID tokens to provided verified claims is also
<strong>Recommended</strong> to provide finer grained access to
services</p></td>
</tr>
<tr class="odd">
<td colspan="2"><strong>MTLS</strong></td>
</tr>
<tr class="even">
<td>MTLS allows a higher level of trust between different parties when
exchanging credentials.</td>
<td><p>When the relying party (who owns the Client, application is
communicating with the OpenID (Identity) Provider for exchanging
credentials it is <strong>Recommended</strong> that it is carried out
over MTLS</p>
<p>It is also <strong>Recommended</strong> that organisations should
implement a proof-of-possession / holder-of-key capability that ties the
MTLS certificate to the Access Token when handling confidential /
restricted information</p></td>
</tr>
<tr class="odd">
<td colspan="2"><strong>JWT (private_key_JWT)</strong></td>
</tr>
<tr class="even">
<td><p>OAuth 2.0 Clients Applications can use Client IDs. and Client
secrets to authenticate to the services (e.g. token generation, user
information and access revoke).</p>
<p>In RFC 7523 the concept of using JWTs for Client Authentication. This
provides additional controls over the standard Client ID and Secret, and
it mandates that the JWT is signed and verified, that it contains the
required claims which are validated, and ones (e.g. jti – JWT ID) that
are used to ensure the JWT is not used twice.</p></td>
<td>It is <strong>Recommended</strong> that organisations implement this
form of client authentication when protecting confidential (and above)
information</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74235000" class="anchor"></span>Table 14: OAuth 2.0
Tokens &amp; Credentials</p>
<h2 id="oauth-scenario-authorisation-code-grant-flow">OAuth Scenario
(Authorisation Code Grant Flow)</h2>
<blockquote>
<p>This is a hypothetical scenario to demonstrate a key OAuth pattern
using the Authorisation Code grant flow. In this scenario IRD has
developed a set of APIs that can be used by professional accounting
firms to offer additional services to their customers.</p>
<p>The assumption here is that IRD have an API Gateway, that offers:</p>
</blockquote>
<ol type="1">
<li><p>API Developer Portal</p></li>
<li><p>OAuth Authorisation Server</p></li>
<li><p>Resource Server, exposing the APIs that can be called</p></li>
<li><p>That IRD are securing an API called “View IRD Return” with an
Authorisation Code Grant Type</p></li>
</ol>
<h3 id="stage-1-develop-the-application-3rd-party">Stage 1 – Develop the
Application (3<sup>rd</sup> Party)</h3>
<blockquote>
<p>The third party (in this case MyAccountantWebsite.com) develops a
client application that will be exposed to their customers when they
login to their website. It will allow customers of MyAccountantWebSite
to authorise and set up delegated access for the MyAccountantWebSite
application to view their IRD returns, but without the customer having
to provide their IRD username and password to MyAccountantWebsite.</p>
<p>The application will use the APIs exposed by IRD and is developed on
an MyAccountantWebsite.com Application (Web) Server that can securely
store security credentials.</p>
</blockquote>
<h3 id="stage-2-register-the-client-application">Stage 2 – Register the
(Client) Application</h3>
<p>The developer needs to register as a user of the IRD API Portal. IRD
needs to verify that this person is allowed to register as a user. (This
process is outside the scope of this document and will vary depending on
the sensitivity of the APIs exposed.)</p>
<p>The authentication of the developer can be via:</p>
<ul>
<li><p>IRD’s internal client login services</p></li>
<li><p>An external Identity Service provided (OpenID Connect or SAML
based, or Social Network Identity provider)</p></li>
</ul>
<p>Once the developer has been approved and has been granted login
credentials (username and password) they log onto the IRD API Portal and
register their client application; this is carried out over a TLS secure
link. The following information is provided:</p>
<ul>
<li><p>The name of the application (by the Developer)</p></li>
<li><p>Return URL (by the Developer)</p></li>
<li><p>Client ID (by IRD) – stored securely</p></li>
<li><p>Client Secret (by IRD) – stored securely</p></li>
</ul>
<p>The developer completes development of the client application on
MyAccountantWebsite. The next steps detail how the MyAccountantWebsite
customer uses the application.</p>
<p>Note: the values of the Client ID and Secret are represented as
simple strings below. In reality these are long, randomly generated
strings.</p>
<p><img src="media/image35.png"
style="width:4.9825in;height:2.84421in" /></p>
<p><span id="_Toc74234891" class="anchor"></span>Figure 39: Stage 2
Client Registration</p>
<h3 id="stage-3-customer-sets-new-service-and-authorises-access">Stage 3
–Customer Sets New Service and Authorises Access</h3>
<p>The Customer logs into MyAccountantWebsite from their browser and
clicks on the IRD button (View IRD) which should allow the user access
to information presented by the “View IRD Return” API (see Figure 21:
Stage 3 Client Registration below). As there is no current “Access
Token” stored for the client application to use, the user is redirected
to the IRD Authorisation Server “Authorisation End Point” with the
following information:</p>
<ol type="1">
<li><p>IRD URL A (Authorisation endpoint URL)</p></li>
<li><p>Return URL (where the authorisation code will be sent)</p></li>
<li><p>Client ID = ABC (random long string that is used to identify the
client application)</p></li>
<li><p>Scope = READ (defined by the application as to what the
application can do)</p></li>
<li><p>State = xyz123 (random long string that is used to mitigate man
in the middle attacks)</p></li>
</ol>
<p><img src="media/image36.png"
style="width:5.42841in;height:3.48075in" /></p>
<p><span id="_Toc74234892" class="anchor"></span>Figure 40: Stage 3
Client Registration</p>
<h3 id="stage-4-authentication-and-approval-by-the-resource-owner">Stage
4 – Authentication and Approval by the Resource Owner</h3>
<p>As the client application doesn’t have an access token for this
customer, or a session set up with IRD, the customer is redirected to
the IRD login page. The customer then logs into IRD and will be
presented with a request to accept the scopes (in this case READ) for
MyAccountantWebsite access.</p>
<p><img src="media/image37.png"
style="width:4.90141in;height:3.45083in" /></p>
<p><span id="_Toc74234893" class="anchor"></span>Figure 41: Stage 4
Client Registration</p>
<h3 id="stage-5-provide-an-authentication-code">Stage 5 – Provide an
Authentication Code</h3>
<p>With the customer’s acceptance of the scope, the Authorisation server
sends an Authorisation code to the client application (with the same
state parameter for the client to validate).</p>
<p><img src="media/image38.png"
style="width:5.09195in;height:3.26501in" /></p>
<p><span id="_Toc74234894" class="anchor"></span>Figure 42: Stage 5
Client Registration</p>
<h3 id="stage-6-authorisation-code-is-sent-to-token-endpoint">Stage 6
–Authorisation Code is Sent to Token Endpoint </h3>
<p>To gain access to API resources, the client application sends the
Authorisation Code to the Token endpoint (T on the diagram below) on the
Authorisation Server, along with the Client ID and Client Secret it
received when the client application was registered. This is used for
authentication of the client application to the authorisation server.
Note: The communication must be over TLS.</p>
<p><img src="media/image39.png"
style="width:5.60314in;height:3.59279in" /></p>
<p><span id="_Toc74234895" class="anchor"></span>Figure 43: Stage 6
Client Registration</p>
<h3 id="stage-7-the-access-token-it-provides">Stage 7 – The Access Token
It Provides</h3>
<p>The Authorisation Server provides an Access token back to the client
application, along with a refresh token (for later use) and an expiry
time for the Access token.</p>
<p><img src="media/image40.png"
style="width:5.14861in;height:3.27158in" /></p>
<p><span id="_Toc74234896" class="anchor"></span>Figure 44: Stage 7
Client Registration</p>
<h3
id="stage-8-the-client-application-uses-the-access-token-to-access-the-resource">Stage
8 – The Client Application uses the Access Token to Access the Resource
</h3>
<p>The Client Application presents the Access Token to the Resource
Server at IRD, which is verified by the Authorisation Server and the
requested data is returned from the IRD back end system via the View IRD
Return API to the MyAccountantWebsite client application.</p>
<p><img src="media/image41.png"
style="width:5.90139in;height:3.78403in" /></p>
<p><span id="_Toc74234897" class="anchor"></span>Figure 45: Stage 8
Client Registration</p>
<p>This completes the OAuth scenario, as the client application has
retrieved, and can use, the resource data returned from the API.</p>
<p><span id="_Toc74234793" class="anchor"></span></p>
<h1 id="appendix-e---authorisation">Appendix E - Authorisation </h1>
<h2 id="abac-implementation">ABAC Implementation</h2>
<p>To implement Attribute Based Access Control, the current models
defined use XACML.</p>
<p>XACML (developed by OASIS), provides a reference architecture, a
request / response protocol and a policy language.</p>
<p>It is a highly distributed and loosely coupled architecture. It
provides very useful generic definitions of the required components
(services) which can be used to define any access control model.</p>
<p>It uses the following services to define the reference
architecture:</p>
<ol type="1">
<li><p>Policy Enforcement Point (PEP) – where the request to the
resource is intercepted and policy applied (based on the decision made
by the Policy Decision Point)</p></li>
<li><p>Policy Decision Point (PDP) – This is the policy server to which
the PEP sends the request for evaluation as to whether a user should or
should not have access to a resource. The PDP has access to policy and
can match the credentials and request against policy to make a
permit/deny decision. It can also enforce policy related obligations
e.g. enhanced logging, notification and alerts, or re-routing to request
additional authorisation process.</p></li>
<li><p>Policy Administration Point (PAP) – The interface where the
policies are developed and defined</p></li>
<li><p>Policy Information Point (PIP) – Used to gather additional
information about a user from Identity stores or databases to provide
additional attributes that are required by the PDP to validate the
policy and apply the required outcome.</p></li>
</ol>
<p>The links and flows between these services are detailed in the
diagram below:<img src="media/image42.png"
style="width:4.64386in;height:2.64106in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234898" class="anchor"></span>Figure 46: XACML
Reference Architecture</p>
<p>XACML is generally perceived as being difficult to write policies in,
but this is being addressed in two ways:</p>
<ol type="1">
<li><p>OASIS is developing a Request/Response Interface based on JSON
and HTTP for XACML 3.0, Version 1.0</p></li>
<li><p>There is a JSON-based language called ALFA (Abbreviated Language
for Authorization) which can be used to build XACML policies</p></li>
</ol>
<p>For XACML to support fine grained access for APIs requires a model
such as is illustrated in the diagram below (based on the scenario in
section 1.5.6).</p>
<p><img src="media/image43.png" style="width:5.83521in;height:1.83131in"
alt="Diagram Description automatically generated" /></p>
<p><span id="_Toc74234899" class="anchor"></span>Figure 47: ABAC Support
for APIs</p>
<blockquote>
<p>It follows these steps:</p>
</blockquote>
<ol type="1">
<li><p>The access token is obtained during the request and exchange
process</p></li>
<li><p>The access token is presented during the resource request to the
PEP, which also exposes the resource</p></li>
<li><p>The access request is passed to the Authorisation Server</p></li>
<li><p>The Authorisation Server verifies the access token and passes a
XACML request to the PDP. This is where additional fine-grained access
can be applied.</p></li>
<li><p>The PDP authorises the PEP to allow access to the back-end
service</p></li>
</ol>
<h1 id="appendix-f---security-controls">Appendix F - Security
Controls</h1>
<p>This section captures a number of key controls that should be
applied. It is recommended that organisations should the relevant RFC
(or active draft documents) that relate to securing APIs. For
example:</p>
<p><a
href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18.txt"><u>https://datatracker.ietf.org/doc/html/draft-ietf-oauth-security-topics-18.txt</u></a></p>
<h2 id="communications-security-confidentiality">Communications Security
(Confidentiality)</h2>
<p><strong><span class="smallcaps">Required</span></strong></p>
<p>All communications to or from an API must be over TLS 1.3 or higher.
Other versions of TLS and SSL should be disabled. This provides a
recognised level of confidentiality that covers all communications
between all components.</p>
<p>The consuming application must validate the TLS certificate chain
when making requests to protected resources, including checking the
Certificate Revocation List (CRL).</p>
<h2 id="state-integrity">State (Integrity)</h2>
<p>State is also a parameter that can be used during the authorisation
grant stage to provide a level of security to address possible
man-in-the-middle attacks. The state parameter is a string of random
letters and numbers that is sent to the Authorisation Server by the
client when requesting an authorisation code. It is sent back to the
client with the Authorisation Code and should be verified by the client
application to confirm the authenticity of the response i.e. it came
from the authorisation server to which the request was sent.</p>
<p>Note: State is used to provide a level of integrity when using the
standard format of bearer tokens. The confidence in the level of
integrity can be increased if JWT tokens are used for bearer tokens.</p>
<h2 id="content-encryption-confidentiality">Content Encryption
(Confidentiality)</h2>
<p>If content needs only to be visible to specific consumer endpoints,
use encryption. However, if content only needs to be guaranteed
untampered and/or from a specific source (e.g. provider) then use
content signing. Content encryption enables all or part of a JSON
payload to be readable only by the target consumer(s). This is useful
where the content being carried by the API is sensitive, and the API
request or response transits multiple stopping points. Whilst TLS
protects the payload in transit, it only applies to each point to point
connection between components (e.g. mobile app to API gateway). If
transit components are not totally under the provider’s control, it can
be worthwhile performing body encryption. E.g. it may be sensible to
encrypt credit card details passed between consumer and provider backend
systems.</p>
<p>It is also worth considering how much protection the information
needs whilst at rest (e.g. information received from consuming
applications, caches) and whether some content should be stored
encrypted.</p>
<p>Encryption is only worthwhile implementing when data sensitivity or
data protection requirements drive it, as encryption is computationally
intensive. It also makes it more difficult for protection mechanisms,
such as API gateways, to validate and transform API content. When only
the integrity of the content passed needs to be ensured, consider using
Content Signing (section 1.7.4) instead.</p>
<p>There are many existing ways of encrypting message content, built
into code libraries and development tools. It is Required that any
content encryption adheres to the standard algorithms laid out in NZISM
(HMAC Algorithms).</p>
<h2 id="content-signing-integrity">Content Signing (Integrity)</h2>
<p>Content signing is used to assure content integrity and proof of
authorship. It can apply to the whole body of the JSON message or
specific elements of that content e.g. credit card details. There are
many approaches to content signing and the most appropriate approach is
requirements dependent. Standard signing algorithms exist within coding
libraries, and JWT has a body which can contain verifiable (signed) JSON
fields. API Gateways can also be configured to sign content objects in
transit, if provided with an appropriate private key.</p>
<p>Signing has less of a computational overhead than encryption, but can
still affect performance, so it is advisable that it be used only when
and where needed.</p>
<p>For APIs, this is a developing area: there are standards currently
under development to address content signing:</p>
<ul>
<li><p>Message Authentication Code - OAuth 2.0 Message Authentication
Code (MAC) Tokens (draft)</p></li>
<li><p>Proof of Possession - OAuth 2.0 Proof-of-Possession (PoP)
Security Architecture (draft)</p></li>
</ul>
<p>It is <strong>Recommended</strong> that where Bearer Tokens are used,
they should be signed using JSON Web Tokens (JWT) as defined in:</p>
<ul>
<li><p>JSON Web Token (JWT) RFC 7519</p></li>
<li><p>JSON Web Signature (JWS) RFC 7515</p></li>
<li><p>JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication
and Authorization Grants RFC 7523</p></li>
</ul>
<h2 id="non-repudiation-integrity">Non-Repudiation (Integrity)</h2>
<p>Non-repudiation covers the means to ensure that a consumer cannot
deny making a request and, similarly, a provider cannot claim they did
not send a response. To aid non-repudiation for APIs, it is important to
ensure credentials are not shared between consumers and to perform
comprehensive logging of API request/responses.</p>
<p>Digital signatures are useful for not just guaranteeing authenticity
and integrity, but also supporting non-repudiation.</p>
<h2 id="availability-and-threat-protection-1">Availability and Threat
Protection</h2>
<p>Below is a table of risk types and some recommended approaches to
help mitigation these threats:</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Threat</th>
<th>Mitigation (OWASP)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Exposure of inappropriate API methods to access services</td>
<td><p>Protect and Limit (whitelist) the HTTP Methods (GET, PUT etc)
exposed</p>
<p>Validate Method(s) for session token / API key.</p></td>
</tr>
<tr class="even">
<td>Denial of Service attacks</td>
<td>Throttle access to all exposed APIs. Monitor use to indicate
possible DoS attacks</td>
</tr>
<tr class="odd">
<td>Malicious Input, Injection attacks and Fuzzing</td>
<td><p>Validate input: Secure parsing and strong typing</p>
<p>Validate incoming content-type application/json</p>
<p>Validate JSON content</p>
<p>Validate XML (schema and format)</p>
<p>Scan attachments</p>
<p>Produce valid HTTP Return Code</p>
<p>Validate response type</p></td>
</tr>
<tr class="even">
<td>Cross-Site Request Forgery</td>
<td>Use tokens with state and nonce parameters</td>
</tr>
<tr class="odd">
<td>Cross-Site Scripting Attacks</td>
<td>Validate Input</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74235001" class="anchor"></span>Table 15: Risks &amp;
Mitigations</p>
<h2 id="token-threat-mitigation">Token Threat Mitigation</h2>
<p>Securing OAuth flows relies on the exchange of tokens between
consuming applications and API backend servers. There is always the
threat of these tokens being obtained illicitly, losing confidentiality
and integrity of message content or the integrity of the sender of the
token. This risk also applies to the transferring of API keys.</p>
<p>The table below captures the main Token threats and possible
mitigation strategies:</p>
<table>
<colgroup>
<col style="width: 47%" />
<col style="width: 52%" />
</colgroup>
<thead>
<tr class="header">
<th>Threat</th>
<th>Mitigation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Token Manufacture or modification (fake tokens and man in the middle
attacks)</td>
<td>Digital signing of tokens (e.g. JWS with JWT) or attaching a Message
Authentication Code (MAC)</td>
</tr>
<tr class="even">
<td><p>Token disclosure – man in the middle attack.</p>
<p>The Access Token is passed in clear text with no hashing, signing or
encryption.</p></td>
<td><p>Communication Security</p>
<p>Use TLS 1.3 with a cipher suite that includes DHE or ECDHE</p>
<p>The client application must validate:</p>
<ul>
<li><p>The TLS certificate chain</p></li>
<li><p>Check the certificate revocation list*</p></li>
</ul>
<p>*Stored locally in a file or LDAP server<a href="#fn10"
class="footnote-ref" id="fnref10"
role="doc-noteref"><sup>10</sup></a></p></td>
</tr>
<tr class="odd">
<td><p>Token Redirects.</p>
<p>Ensure the Authentication and Resource Servers are “paired”, and the
access token can only be used in this between the specified
servers</p></td>
<td><p>Using the “audience” header (defined currently in a draft RFC)
the client application, resource server and authorisation server can
help* ensure that the token can only be used on the resource servers
requested by the client and recognised by the authorisation server.</p>
<p>Also addressed with “state” parameter in the header</p>
<blockquote>
<p>* Signing of tokens is also applicable to address token redirects</p>
</blockquote></td>
</tr>
<tr class="even">
<td>Token replay – where the threat actor copies an existing token (e.g.
refresh token or authorisation code) and reuses it on their own
request</td>
<td><p>Limit lifetime of the token (e.g. 10 minutes) – turning it into a
short-lived issue</p>
<p>Use signed requests along with nonce and timestamps</p>
<p>Validate TLS certificate chain when accessing Resource
Server</p></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74235002" class="anchor"></span>Table 16: Token Threat
Mitigation</p>
<p>API Gateway capabilities can protect against many typical API
vulnerabilities and threats. Typically, these relate to:</p>
<ul>
<li><p>Throttling to prevent Denial of Service attacks</p></li>
<li><p>Message analysis to block HTTP attacks; parameter attacks such as
cross-site scripting, SQL injection, command injection and cross site
request forgery</p></li>
<li><p>Controlling egress of information via the API, aligned to set
access permissions/policies</p></li>
</ul>
<p>As well as providing (if required) access control to API
functionality.</p>
<p><span id="_Toc74234803" class="anchor"></span></p>
<h1 id="appendix-g---ietf-nfc-relating-to-oauth-2.0">Appendix G - IETF
NFC Relating to OAuth 2.0</h1>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>RFC number and Title</th>
<th>High Level Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>RFC 6749</p>
<p>The OAuth 2.0 Authorization Framework</p></td>
<td>The core OAuth 2.0 RFC defining the authorisation framework.</td>
</tr>
<tr class="even">
<td><p>RFC 6750</p>
<p>The OAuth 2.0 Authorisation Framework: Bearer Token Usage</p></td>
<td><p>How to use bearer tokens in HTTP requests to access OAuth 2.0
protected resources. Any party in possession of a bearer token (a
"bearer") can use it to get access to the associated resources (without
demonstrating possession of a cryptographic key). To prevent misuse,
bearer tokens need to be protected from disclosure in storage and in
transport.</p>
<p>Note: RFC 8996 deprecates TLS 1.0 and 1.1 and recommends 1.2 or
ideally 1.3 in OAuth 2.0 implementations)</p></td>
</tr>
<tr class="odd">
<td><p>RFC 6819</p>
<p>OAuth 2.0 Threat Model and Security Considerations</p></td>
<td>Security considerations for OAuth beyond those in the OAuth 2.0
specification, based on a comprehensive threat model for the OAuth 2.0
protocol.</td>
</tr>
<tr class="even">
<td><p>RFC 7009</p>
<p>Token Revocation</p></td>
<td>This profile defines a revocation endpoint on the authorisation
server to enable clients (consuming applications) to revoke their own
access or refresh tokens. This is essential should a token get into the
wrong hands and be used for malicious purposes. Before allowing a client
to revoke an access token and/or associated refresh tokens, the
authorisation server first validates the client’s credentials.</td>
</tr>
<tr class="odd">
<td><p>RFC 7519</p>
<p>JSON Web Token (JWT)</p></td>
<td>URL-safe means of representing claims to be transferred between two
parties. The claims in a JWT are encoded as a JSON object that is used
as the payload of a JSON Web Signature (JWS) structure or as the
plaintext of a JSON Web Encryption (JWE) structure, enabling the claims
to be digitally signed or integrity protected with a Message
Authentication Code (MAC) and/or encryption.</td>
</tr>
<tr class="even">
<td><p>RFC 8725</p>
<p>JSON Web Token Best Current Practices</p></td>
<td>This document updates RFC 7519 to provide actionable guidance
leading to secure implementation and deployment of JWTs.</td>
</tr>
<tr class="odd">
<td></td>
<td></td>
</tr>
<tr class="even">
<td><p>RF7521</p>
<p>Assertion Framework for OAuth 2.0 Client Authentication and
Authorisation Grants</p></td>
<td>Common framework for OAuth 2.0 to interact with other identity
systems using an assertion and to provide alternative client
authentication mechanisms.</td>
</tr>
<tr class="odd">
<td><p>RFC 7522</p>
<p>Security Assertion Markup Language (SAML) 2.0 Profile for OAuth 2.0
Client Authentication and Authorization Grants</p></td>
<td>The use of a Security Assertion Markup Language (SAML) 2.0 Bearer
Assertion as a means for requesting an OAuth 2.0 access token as well as
for client authentication.</td>
</tr>
<tr class="even">
<td><p>RFC 7523</p>
<p>JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and
Authorization Grants</p></td>
<td>Use of a JSON Web Token (JWT) Bearer Token as a means for requesting
an OAuth 2.0 access token as well as for client authentication.</td>
</tr>
<tr class="odd">
<td><p>RFC 7591</p>
<p>OAuth 2.0 Dynamic Client Registration Protocol</p></td>
<td>Mechanisms for dynamically registering OAuth 2.0 clients with
authorisation servers.</td>
</tr>
<tr class="even">
<td><p>RFC 7592</p>
<p>OAuth 2.0 Dynamic Client Registration Management Protocol</p></td>
<td>Methods for the management of OAuth 2.0 dynamic client registrations
for use cases in which the properties of a registered client may need to
be changed during the lifetime of the client.</td>
</tr>
<tr class="odd">
<td><p>RFC 7662</p>
<p>OAuth 2.0 Token Introspection</p></td>
<td>Method for a protected resource to query an OAuth 2.0 authorisation
server to determine the active state of an OAuth 2.0 token and to
determine meta-information about this token. Provides authorisation
context of the token from the authorisation server to the protected
resource.</td>
</tr>
<tr class="even">
<td><p>RFC 7800</p>
<p>Proof-of-Possession Key Semantics for JSON Web Tokens (JWTs)</p></td>
<td>How to declare in a JSON Web Token (JWT) that the presenter of the
JWT possesses a particular proof-of-possession key and how the recipient
can cryptographically confirm proof of possession of the key by the
presenter.</td>
</tr>
<tr class="odd">
<td><p>RFC 7636</p>
<p>Proof Key for Code Exchange by OAuth Public Clients</p></td>
<td>OAuth 2.0 public clients utilising the Authorisation Code Grant are
susceptible to the authorisation code interception attack. This
specification describes the attack as well as a technique to mitigate
against the threat through the use of Proof Key for Code Exchange.</td>
</tr>
<tr class="even">
<td><p>RFC 8176</p>
<p>Authentication Method Reference Values</p></td>
<td><p>Establishing a registry for Authentication methods for
example:</p>
<ul>
<li><p>Retina Scan</p></li>
<li><p>Facial Recognition</p></li>
<li><p>Fingerprints</p></li>
<li><p>Geolocation information</p></li>
<li><p>Proof of possession of a hardware key</p></li>
<li><p>Knowledge based authentication</p></li>
<li><p>Multi-channel authentication</p></li>
<li><p>Multi-factor authentication</p></li>
<li><p>One-time password</p></li>
<li><p>Personal Identification Number</p></li>
<li><p>Password based</p></li>
<li><p>Risk Based</p></li>
<li><p>SMS confirmation messages</p></li>
<li><p>Proof of possession of a software key</p></li>
<li><p>Confirm by telephone</p></li>
<li><p>User presence test</p></li>
<li><p>Voice biometrics</p></li>
<li><p>Windows integration</p></li>
</ul></td>
</tr>
<tr class="odd">
<td><p>RFC 8252</p>
<p>OAuth 2.0 for Native Apps</p></td>
<td>This RFC recommends external user-agents like in-app browser tabs as
the only secure and usable choice for OAuth, rather than embedded
user-agents.</td>
</tr>
<tr class="even">
<td><p>RFC 8414</p>
<p>OAuth 2.0 Authorization Server Discovery Metadata</p></td>
<td>This defines how an OAuth 2.0 Client can interact with an
authorisation server by providing a discovery endpoint that provides the
endpoints and authorisation server capability.</td>
</tr>
<tr class="odd">
<td><p>RFC 8628</p>
<p>OAuth 2.0 Device Authorization Grant</p></td>
<td>The OAuth 2.0 device authorisation grant is designed for
Internet-connected devices that either lack a browser to perform a
user-agent-based authorisation or are input constrained to the extent
that requiring the user to input text in order to authenticate during
the authorisation flow is impractical. It enables OAuth clients on such
devices (like smart TVs, media consoles, digital picture frames, and
printers) to obtain user authorisation to access protected resources by
using a user agent on a separate device.</td>
</tr>
<tr class="even">
<td><p>RFC 8693</p>
<p>OAuth 2.0 Token Exchange</p></td>
<td>Defines a protocol for a lightweight HTTP and JSON based Security
Token Service (STS) – covering requests of tokens from an Authorisation
Server.</td>
</tr>
<tr class="odd">
<td><p>RFC 8705</p>
<p>OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound
Access Tokens</p></td>
<td><p>This document describes OAuth client authentication and
certificate-bound access and refresh tokens using mutual Transport Layer
Security (TLS) authentication with X.509 certificates.</p>
<p>OAuth clients are provided a mechanism for authentication to the
authorisation server using mutual TLS.</p>
<p>OAuth authorisation servers are provided a mechanism for binding
access tokens to a client's mutual-TLS certificate, and OAuth protected
resources are provided a method for ensuring that such an access token
presented to it was issued to the client presenting the token</p></td>
</tr>
<tr class="even">
<td><p>RFC 8707</p>
<p>Resource Indicators for OAuth 2.0</p></td>
<td>This document specifies an extension to the OAuth 2.0 Authorisation
Framework defining request parameters that enable a client to explicitly
signal to an authorisation server about the identity of the protected
resource(s) to which it is requesting access.</td>
</tr>
<tr class="odd">
<td><p>RFC 6755</p>
<p>An IETF URN Sub-Namespace for OAuth</p></td>
<td>This document establishes an IETF URN Sub-namespace for use with
OAuth-related specifications.</td>
</tr>
</tbody>
</table>
<p><span id="_Toc74235003" class="anchor"></span>Table 17: IETF NFC
Relating to OAuth 2.0</p>
<h1 id="appendix-h---rfcs-in-development">Appendix H - RFCs in
Development</h1>
<p>The following are RFCs which are pertinent to this standard but are
currently under development:</p>
<table>
<colgroup>
<col style="width: 48%" />
<col style="width: 51%" />
</colgroup>
<thead>
<tr class="header">
<th>Description</th>
<th>High Level view</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>OAuth 2.0 JWT Secured Authorization Request</td>
<td>This document introduces the ability to send request parameters in a
JSON Web Token (JWT) instead, which allows the request to be signed with
JSON Web Signature (JWS) and encrypted with JSON Web Encryption (JWE) so
that the integrity, source authentication and confidentiality property
of the Authorization Request is attained.</td>
</tr>
<tr class="even">
<td>JWT Response for OAuth Token Introspection</td>
<td>The introspection response, as specified in OAuth 2.0 Token is a
plain JSON object. This specification extends the token introspection
endpoint with the capability to return responses as JWTs.</td>
</tr>
<tr class="odd">
<td>JSON Web Token (JWT) Profile for OAuth 2.0 Access Tokens</td>
<td>This specification defines a profile for issuing OAuth 2.0 access
tokens in JSON web token (JWT) format. Authorisation servers and
resource servers from different vendors can leverage this profile to
issue and consume access tokens in an interoperable manner.</td>
</tr>
<tr class="even">
<td>The OAuth 2.1 Authorization Framework</td>
<td><p>This is an in-progress update to version 2.0, Key points to note
are:</p>
<ol type="1">
<li><p>PKCE is required for all OAuth clients using the authorization
code flow</p></li>
<li><p>Redirect URIs must be compared using exact string
matching</p></li>
<li><p>The following grants are omitted:</p>
<ol type="a">
<li><p>The Implicit grant</p></li>
<li><p>The Resource Owner Password Credentials</p></li>
</ol></li>
<li><p>Bearer token usage omits the use of bearer tokens in the query
string of URIs</p></li>
<li><p>Refresh tokens for public clients must either be
sender-constrained or one-time use</p></li>
</ol></td>
</tr>
<tr class="odd">
<td>OAuth 2.0 Security Best Current Practice</td>
<td>This document describes best current security practice for OAuth
2.0. It updates and extends the OAuth 2.0 Security Threat Model to
incorporate practical experiences gathered since OAuth 2.0 was published
and covers new threats relevant due to the broader application of OAuth
2.0.</td>
</tr>
<tr class="even">
<td>OAuth 2.0 Rich Authorization Requests</td>
<td>This document specifies a new parameter "authorization_details" that
is used to carry fine grained authorisation data in the OAuth
authorisation request.</td>
</tr>
<tr class="odd">
<td>OAuth 2.0 Pushed Authorization Requests</td>
<td>Pushed authorization requests (PAR)enable OAuth Clients to push the
payload of an authorisation request directly to the authorisation server
in exchange for a request URI value, which is used as reference to the
authorisation request payload data in a subsequent call to the
authorisation endpoint via the user-agent.</td>
</tr>
<tr class="even">
<td>OAuth 2.0 Authorization Server Issuer Identifier in Authorization
Response</td>
<td>This specifies a new parameter "iss" that is used to explicitly
include the issuer identifier of the authorisation server in the
authorisation response of an OAuth authorisation flow. If implemented
correctly, the "iss" parameter serves as an effective countermeasure to
"mix-up attacks" which are aimed to steal an authorisation code or
access token by tricking the client into sending the authorisation code
or access token to the attacker instead of the honest authorisation or
resource server.</td>
</tr>
<tr class="odd">
<td>OAuth 2.0 Demonstrating Proof-of-Possession at the Application
Layer</td>
<td><p>This specification describes a mechanism for sender-constraining
OAuth 2.0 tokens via a proof-of-possession mechanism on the application
level and enables a client to demonstrate proof-of-possession of a
public/private key pair by including a "DPoP" header (JWT) in an HTTP
request, that enables the authorisation server to bind issued tokens to
the public part of a client's key pair.</p>
<p>This mechanism allows for the detection of replay attacks with access
and refresh tokens.</p></td>
</tr>
<tr class="even">
<td>OAuth 2.0 for Browser-Based Apps</td>
<td><p>This specification describes the current best practices for
implementing OAuth 2.0 authorization flows in applications executing in
a browser.</p>
<p>An application that is dynamically downloaded and executed in a web
browser, usually written in JavaScript. Also, sometimes referred to as a
"single-page application", or "SPA".</p>
<p>One of the key recommendations is the use of PKCE.</p></td>
</tr>
</tbody>
</table>
<p><span id="_Toc74235004" class="anchor"></span>Table 18: RFCs in
Development</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>Identity relates to how a person (or thing) is
represented and how this is used to access services or information. See
https://www.digital.govt.nz/digital-government/programmes-and-projects/digital-identity-programme/what-is-digital-identity/<a
href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p><a
href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf"><u>https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-207.pdf</u></a><a
href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>For more details, see Appendix C - OAuth 2<a
href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p><a
href="https://kantarainitiative.org/confluence/display/uma/Home"><u>https://kantarainitiative.org/confluence/display/uma/Home</u></a><a
href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p><a
href="https://www.gluu.org/"><u>https://www.gluu.org/</u></a> and <a
href="https://forgerock.org"><u>https://forgerock.org</u></a> and <a
href="https://wso2.com"><u>https://wso2.com</u></a> and <a
href="https://www.keycloak.org"><u>https://www.keycloak.org</u></a><a
href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p><a
href="https://www.standards.govt.nz"><u>https://www.standards.govt.nz</u></a><a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li
id="fn7"><p><u>https://www.ict.govt.nz/guidance-and-resources/information-management/requirements-for-cloud-computing/vendor-answer-sets/</u><a
href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8"><p>The NZ Evidence of Identity Standard defines levels of
identity risk.<a href="#fnref8" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn9"><p>Refer to the New Zealand Government Security
Classification System and the New Zealand Information Security Manual
for information about when stronger authentication techniques may be
necessary.<a href="#fnref9" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn10"><p>The process for obtaining this information is out of
scope for this document<a href="#fnref10" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
</ol>
</aside>
